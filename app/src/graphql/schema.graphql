# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type Admin {
  firstName: String!
  id: Int!
  lastName: String!
  user: User!
  userId: Int!
}

type AdminAvgAggregate {
  id: Float
  userId: Float
}

input AdminAvgOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

type AdminCountAggregate {
  _all: Int!
  firstName: Int!
  id: Int!
  lastName: Int!
  userId: Int!
}

input AdminCountOrderByAggregateInput {
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  userId: SortOrder
}

input AdminCreateInput {
  firstName: String!
  lastName: String!
  user: UserCreateNestedOneWithoutAdminInput!
}

input AdminCreateNestedOneWithoutUserInput {
  connect: AdminWhereUniqueInput
  connectOrCreate: AdminCreateOrConnectWithoutUserInput
  create: AdminCreateWithoutUserInput
}

input AdminCreateOrConnectWithoutUserInput {
  create: AdminCreateWithoutUserInput!
  where: AdminWhereUniqueInput!
}

input AdminCreateWithoutUserInput {
  firstName: String!
  lastName: String!
}

type AdminGroupBy {
  _avg: AdminAvgAggregate
  _count: AdminCountAggregate
  _max: AdminMaxAggregate
  _min: AdminMinAggregate
  _sum: AdminSumAggregate
  firstName: String!
  id: Int!
  lastName: String!
  userId: Int!
}

type AdminMaxAggregate {
  firstName: String
  id: Int
  lastName: String
  userId: Int
}

input AdminMaxOrderByAggregateInput {
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  userId: SortOrder
}

type AdminMinAggregate {
  firstName: String
  id: Int
  lastName: String
  userId: Int
}

input AdminMinOrderByAggregateInput {
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  userId: SortOrder
}

input AdminOrderByWithAggregationInput {
  _avg: AdminAvgOrderByAggregateInput
  _count: AdminCountOrderByAggregateInput
  _max: AdminMaxOrderByAggregateInput
  _min: AdminMinOrderByAggregateInput
  _sum: AdminSumOrderByAggregateInput
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  userId: SortOrder
}

input AdminOrderByWithRelationInput {
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input AdminRelationFilter {
  is: AdminWhereInput
  isNot: AdminWhereInput
}

enum AdminScalarFieldEnum {
  firstName
  id
  lastName
  userId
}

input AdminScalarWhereWithAggregatesInput {
  AND: [AdminScalarWhereWithAggregatesInput!]
  NOT: [AdminScalarWhereWithAggregatesInput!]
  OR: [AdminScalarWhereWithAggregatesInput!]
  firstName: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type AdminSumAggregate {
  id: Int
  userId: Int
}

input AdminSumOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

input AdminUpdateInput {
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutAdminInput
}

input AdminUpdateManyMutationInput {
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
}

input AdminUpdateOneWithoutUserInput {
  connect: AdminWhereUniqueInput
  connectOrCreate: AdminCreateOrConnectWithoutUserInput
  create: AdminCreateWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  update: AdminUpdateWithoutUserInput
  upsert: AdminUpsertWithoutUserInput
}

input AdminUpdateWithoutUserInput {
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
}

input AdminUpsertWithoutUserInput {
  create: AdminCreateWithoutUserInput!
  update: AdminUpdateWithoutUserInput!
}

input AdminWhereInput {
  AND: [AdminWhereInput!]
  NOT: [AdminWhereInput!]
  OR: [AdminWhereInput!]
  firstName: StringFilter
  id: IntFilter
  lastName: StringFilter
  user: UserRelationFilter
  userId: IntFilter
}

input AdminWhereUniqueInput {
  id: Int
  userId: Int
}

type AffectedRowsOutput {
  count: Int!
}

type AggregateAdmin {
  _avg: AdminAvgAggregate
  _count: AdminCountAggregate
  _max: AdminMaxAggregate
  _min: AdminMinAggregate
  _sum: AdminSumAggregate
}

type AggregateAssignment {
  _avg: AssignmentAvgAggregate
  _count: AssignmentCountAggregate
  _max: AssignmentMaxAggregate
  _min: AssignmentMinAggregate
  _sum: AssignmentSumAggregate
}

type AggregateAssignmentFile {
  _avg: AssignmentFileAvgAggregate
  _count: AssignmentFileCountAggregate
  _max: AssignmentFileMaxAggregate
  _min: AssignmentFileMinAggregate
  _sum: AssignmentFileSumAggregate
}

type AggregateCourse {
  _avg: CourseAvgAggregate
  _count: CourseCountAggregate
  _max: CourseMaxAggregate
  _min: CourseMinAggregate
  _sum: CourseSumAggregate
}

type AggregateDepartment {
  _avg: DepartmentAvgAggregate
  _count: DepartmentCountAggregate
  _max: DepartmentMaxAggregate
  _min: DepartmentMinAggregate
  _sum: DepartmentSumAggregate
}

type AggregateLesson {
  _avg: LessonAvgAggregate
  _count: LessonCountAggregate
  _max: LessonMaxAggregate
  _min: LessonMinAggregate
  _sum: LessonSumAggregate
}

type AggregateLessonFile {
  _avg: LessonFileAvgAggregate
  _count: LessonFileCountAggregate
  _max: LessonFileMaxAggregate
  _min: LessonFileMinAggregate
  _sum: LessonFileSumAggregate
}

type AggregateMeeting {
  _avg: MeetingAvgAggregate
  _count: MeetingCountAggregate
  _max: MeetingMaxAggregate
  _min: MeetingMinAggregate
  _sum: MeetingSumAggregate
}

type AggregateStudent {
  _avg: StudentAvgAggregate
  _count: StudentCountAggregate
  _max: StudentMaxAggregate
  _min: StudentMinAggregate
  _sum: StudentSumAggregate
}

type AggregateSubmission {
  _avg: SubmissionAvgAggregate
  _count: SubmissionCountAggregate
  _max: SubmissionMaxAggregate
  _min: SubmissionMinAggregate
  _sum: SubmissionSumAggregate
}

type AggregateSubmissionFile {
  _avg: SubmissionFileAvgAggregate
  _count: SubmissionFileCountAggregate
  _max: SubmissionFileMaxAggregate
  _min: SubmissionFileMinAggregate
  _sum: SubmissionFileSumAggregate
}

type AggregateTeacher {
  _avg: TeacherAvgAggregate
  _count: TeacherCountAggregate
  _max: TeacherMaxAggregate
  _min: TeacherMinAggregate
  _sum: TeacherSumAggregate
}

type AggregateTopic {
  _avg: TopicAvgAggregate
  _count: TopicCountAggregate
  _max: TopicMaxAggregate
  _min: TopicMinAggregate
  _sum: TopicSumAggregate
}

type AggregateUser {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
}

type Assignment {
  _count: AssignmentCount
  assignmentFiles(cursor: AssignmentFileWhereUniqueInput, distinct: [AssignmentFileScalarFieldEnum!], orderBy: [AssignmentFileOrderByWithRelationInput!], skip: Int, take: Int, where: AssignmentFileWhereInput): [AssignmentFile!]!
  content: String!
  course: Course
  courseId: Int
  createdAt: DateTime!
  description: String
  id: Int!
  published: Boolean!
  submissions(cursor: SubmissionWhereUniqueInput, distinct: [SubmissionScalarFieldEnum!], orderBy: [SubmissionOrderByWithRelationInput!], skip: Int, take: Int, where: SubmissionWhereInput): [Submission!]!
  title: String!
  updatedAt: DateTime!
}

type AssignmentAvgAggregate {
  courseId: Float
  id: Float
}

input AssignmentAvgOrderByAggregateInput {
  courseId: SortOrder
  id: SortOrder
}

type AssignmentCount {
  assignmentFiles: Int!
  submissions: Int!
}

type AssignmentCountAggregate {
  _all: Int!
  content: Int!
  courseId: Int!
  createdAt: Int!
  description: Int!
  id: Int!
  published: Int!
  title: Int!
  updatedAt: Int!
}

input AssignmentCountOrderByAggregateInput {
  content: SortOrder
  courseId: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  published: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input AssignmentCreateInput {
  assignmentFiles: AssignmentFileCreateNestedManyWithoutAssignmentInput
  content: String!
  course: CourseCreateNestedOneWithoutAssignmentsInput
  createdAt: DateTime
  description: String
  published: Boolean!
  submissions: SubmissionCreateNestedManyWithoutAssignmentInput
  title: String!
  updatedAt: DateTime
}

input AssignmentCreateNestedManyWithoutCourseInput {
  connect: [AssignmentWhereUniqueInput!]
  connectOrCreate: [AssignmentCreateOrConnectWithoutCourseInput!]
  create: [AssignmentCreateWithoutCourseInput!]
}

input AssignmentCreateNestedOneWithoutAssignmentFilesInput {
  connect: AssignmentWhereUniqueInput
  connectOrCreate: AssignmentCreateOrConnectWithoutAssignmentFilesInput
  create: AssignmentCreateWithoutAssignmentFilesInput
}

input AssignmentCreateNestedOneWithoutSubmissionsInput {
  connect: AssignmentWhereUniqueInput
  connectOrCreate: AssignmentCreateOrConnectWithoutSubmissionsInput
  create: AssignmentCreateWithoutSubmissionsInput
}

input AssignmentCreateOrConnectWithoutAssignmentFilesInput {
  create: AssignmentCreateWithoutAssignmentFilesInput!
  where: AssignmentWhereUniqueInput!
}

input AssignmentCreateOrConnectWithoutCourseInput {
  create: AssignmentCreateWithoutCourseInput!
  where: AssignmentWhereUniqueInput!
}

input AssignmentCreateOrConnectWithoutSubmissionsInput {
  create: AssignmentCreateWithoutSubmissionsInput!
  where: AssignmentWhereUniqueInput!
}

input AssignmentCreateWithoutAssignmentFilesInput {
  content: String!
  course: CourseCreateNestedOneWithoutAssignmentsInput
  createdAt: DateTime
  description: String
  published: Boolean!
  submissions: SubmissionCreateNestedManyWithoutAssignmentInput
  title: String!
  updatedAt: DateTime
}

input AssignmentCreateWithoutCourseInput {
  assignmentFiles: AssignmentFileCreateNestedManyWithoutAssignmentInput
  content: String!
  createdAt: DateTime
  description: String
  published: Boolean!
  submissions: SubmissionCreateNestedManyWithoutAssignmentInput
  title: String!
  updatedAt: DateTime
}

input AssignmentCreateWithoutSubmissionsInput {
  assignmentFiles: AssignmentFileCreateNestedManyWithoutAssignmentInput
  content: String!
  course: CourseCreateNestedOneWithoutAssignmentsInput
  createdAt: DateTime
  description: String
  published: Boolean!
  title: String!
  updatedAt: DateTime
}

type AssignmentFile {
  assignment: Assignment
  assignmentId: Int
  createdAt: DateTime!
  id: Int!
  link: String!
  name: String!
  type: String!
  updatedAt: DateTime!
}

type AssignmentFileAvgAggregate {
  assignmentId: Float
  id: Float
}

input AssignmentFileAvgOrderByAggregateInput {
  assignmentId: SortOrder
  id: SortOrder
}

type AssignmentFileCountAggregate {
  _all: Int!
  assignmentId: Int!
  createdAt: Int!
  id: Int!
  link: Int!
  name: Int!
  type: Int!
  updatedAt: Int!
}

input AssignmentFileCountOrderByAggregateInput {
  assignmentId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  link: SortOrder
  name: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

input AssignmentFileCreateInput {
  assignment: AssignmentCreateNestedOneWithoutAssignmentFilesInput
  createdAt: DateTime
  link: String!
  name: String!
  type: String!
  updatedAt: DateTime
}

input AssignmentFileCreateNestedManyWithoutAssignmentInput {
  connect: [AssignmentFileWhereUniqueInput!]
  connectOrCreate: [AssignmentFileCreateOrConnectWithoutAssignmentInput!]
  create: [AssignmentFileCreateWithoutAssignmentInput!]
}

input AssignmentFileCreateOrConnectWithoutAssignmentInput {
  create: AssignmentFileCreateWithoutAssignmentInput!
  where: AssignmentFileWhereUniqueInput!
}

input AssignmentFileCreateWithoutAssignmentInput {
  createdAt: DateTime
  link: String!
  name: String!
  type: String!
  updatedAt: DateTime
}

type AssignmentFileGroupBy {
  _avg: AssignmentFileAvgAggregate
  _count: AssignmentFileCountAggregate
  _max: AssignmentFileMaxAggregate
  _min: AssignmentFileMinAggregate
  _sum: AssignmentFileSumAggregate
  assignmentId: Int
  createdAt: DateTime!
  id: Int!
  link: String!
  name: String!
  type: String!
  updatedAt: DateTime!
}

input AssignmentFileListRelationFilter {
  every: AssignmentFileWhereInput
  none: AssignmentFileWhereInput
  some: AssignmentFileWhereInput
}

type AssignmentFileMaxAggregate {
  assignmentId: Int
  createdAt: DateTime
  id: Int
  link: String
  name: String
  type: String
  updatedAt: DateTime
}

input AssignmentFileMaxOrderByAggregateInput {
  assignmentId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  link: SortOrder
  name: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

type AssignmentFileMinAggregate {
  assignmentId: Int
  createdAt: DateTime
  id: Int
  link: String
  name: String
  type: String
  updatedAt: DateTime
}

input AssignmentFileMinOrderByAggregateInput {
  assignmentId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  link: SortOrder
  name: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

input AssignmentFileOrderByRelationAggregateInput {
  _count: SortOrder
}

input AssignmentFileOrderByWithAggregationInput {
  _avg: AssignmentFileAvgOrderByAggregateInput
  _count: AssignmentFileCountOrderByAggregateInput
  _max: AssignmentFileMaxOrderByAggregateInput
  _min: AssignmentFileMinOrderByAggregateInput
  _sum: AssignmentFileSumOrderByAggregateInput
  assignmentId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  link: SortOrder
  name: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

input AssignmentFileOrderByWithRelationInput {
  assignment: AssignmentOrderByWithRelationInput
  assignmentId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  link: SortOrder
  name: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

enum AssignmentFileScalarFieldEnum {
  assignmentId
  createdAt
  id
  link
  name
  type
  updatedAt
}

input AssignmentFileScalarWhereInput {
  AND: [AssignmentFileScalarWhereInput!]
  NOT: [AssignmentFileScalarWhereInput!]
  OR: [AssignmentFileScalarWhereInput!]
  assignmentId: IntNullableFilter
  createdAt: DateTimeFilter
  id: IntFilter
  link: StringFilter
  name: StringFilter
  type: StringFilter
  updatedAt: DateTimeFilter
}

input AssignmentFileScalarWhereWithAggregatesInput {
  AND: [AssignmentFileScalarWhereWithAggregatesInput!]
  NOT: [AssignmentFileScalarWhereWithAggregatesInput!]
  OR: [AssignmentFileScalarWhereWithAggregatesInput!]
  assignmentId: IntNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  link: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  type: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type AssignmentFileSumAggregate {
  assignmentId: Int
  id: Int
}

input AssignmentFileSumOrderByAggregateInput {
  assignmentId: SortOrder
  id: SortOrder
}

input AssignmentFileUpdateInput {
  assignment: AssignmentUpdateOneWithoutAssignmentFilesInput
  createdAt: DateTimeFieldUpdateOperationsInput
  link: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AssignmentFileUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  link: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AssignmentFileUpdateManyWithWhereWithoutAssignmentInput {
  data: AssignmentFileUpdateManyMutationInput!
  where: AssignmentFileScalarWhereInput!
}

input AssignmentFileUpdateManyWithoutAssignmentInput {
  connect: [AssignmentFileWhereUniqueInput!]
  connectOrCreate: [AssignmentFileCreateOrConnectWithoutAssignmentInput!]
  create: [AssignmentFileCreateWithoutAssignmentInput!]
  delete: [AssignmentFileWhereUniqueInput!]
  deleteMany: [AssignmentFileScalarWhereInput!]
  disconnect: [AssignmentFileWhereUniqueInput!]
  set: [AssignmentFileWhereUniqueInput!]
  update: [AssignmentFileUpdateWithWhereUniqueWithoutAssignmentInput!]
  updateMany: [AssignmentFileUpdateManyWithWhereWithoutAssignmentInput!]
  upsert: [AssignmentFileUpsertWithWhereUniqueWithoutAssignmentInput!]
}

input AssignmentFileUpdateWithWhereUniqueWithoutAssignmentInput {
  data: AssignmentFileUpdateWithoutAssignmentInput!
  where: AssignmentFileWhereUniqueInput!
}

input AssignmentFileUpdateWithoutAssignmentInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  link: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AssignmentFileUpsertWithWhereUniqueWithoutAssignmentInput {
  create: AssignmentFileCreateWithoutAssignmentInput!
  update: AssignmentFileUpdateWithoutAssignmentInput!
  where: AssignmentFileWhereUniqueInput!
}

input AssignmentFileWhereInput {
  AND: [AssignmentFileWhereInput!]
  NOT: [AssignmentFileWhereInput!]
  OR: [AssignmentFileWhereInput!]
  assignment: AssignmentRelationFilter
  assignmentId: IntNullableFilter
  createdAt: DateTimeFilter
  id: IntFilter
  link: StringFilter
  name: StringFilter
  type: StringFilter
  updatedAt: DateTimeFilter
}

input AssignmentFileWhereUniqueInput {
  id: Int
}

type AssignmentGroupBy {
  _avg: AssignmentAvgAggregate
  _count: AssignmentCountAggregate
  _max: AssignmentMaxAggregate
  _min: AssignmentMinAggregate
  _sum: AssignmentSumAggregate
  content: String!
  courseId: Int
  createdAt: DateTime!
  description: String
  id: Int!
  published: Boolean!
  title: String!
  updatedAt: DateTime!
}

input AssignmentListRelationFilter {
  every: AssignmentWhereInput
  none: AssignmentWhereInput
  some: AssignmentWhereInput
}

type AssignmentMaxAggregate {
  content: String
  courseId: Int
  createdAt: DateTime
  description: String
  id: Int
  published: Boolean
  title: String
  updatedAt: DateTime
}

input AssignmentMaxOrderByAggregateInput {
  content: SortOrder
  courseId: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  published: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

type AssignmentMinAggregate {
  content: String
  courseId: Int
  createdAt: DateTime
  description: String
  id: Int
  published: Boolean
  title: String
  updatedAt: DateTime
}

input AssignmentMinOrderByAggregateInput {
  content: SortOrder
  courseId: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  published: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input AssignmentOrderByRelationAggregateInput {
  _count: SortOrder
}

input AssignmentOrderByWithAggregationInput {
  _avg: AssignmentAvgOrderByAggregateInput
  _count: AssignmentCountOrderByAggregateInput
  _max: AssignmentMaxOrderByAggregateInput
  _min: AssignmentMinOrderByAggregateInput
  _sum: AssignmentSumOrderByAggregateInput
  content: SortOrder
  courseId: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  published: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input AssignmentOrderByWithRelationInput {
  assignmentFiles: AssignmentFileOrderByRelationAggregateInput
  content: SortOrder
  course: CourseOrderByWithRelationInput
  courseId: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  published: SortOrder
  submissions: SubmissionOrderByRelationAggregateInput
  title: SortOrder
  updatedAt: SortOrder
}

input AssignmentRelationFilter {
  is: AssignmentWhereInput
  isNot: AssignmentWhereInput
}

enum AssignmentScalarFieldEnum {
  content
  courseId
  createdAt
  description
  id
  published
  title
  updatedAt
}

input AssignmentScalarWhereInput {
  AND: [AssignmentScalarWhereInput!]
  NOT: [AssignmentScalarWhereInput!]
  OR: [AssignmentScalarWhereInput!]
  content: StringFilter
  courseId: IntNullableFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  id: IntFilter
  published: BoolFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input AssignmentScalarWhereWithAggregatesInput {
  AND: [AssignmentScalarWhereWithAggregatesInput!]
  NOT: [AssignmentScalarWhereWithAggregatesInput!]
  OR: [AssignmentScalarWhereWithAggregatesInput!]
  content: StringWithAggregatesFilter
  courseId: IntNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  description: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  published: BoolWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type AssignmentSumAggregate {
  courseId: Int
  id: Int
}

input AssignmentSumOrderByAggregateInput {
  courseId: SortOrder
  id: SortOrder
}

input AssignmentUpdateInput {
  assignmentFiles: AssignmentFileUpdateManyWithoutAssignmentInput
  content: StringFieldUpdateOperationsInput
  course: CourseUpdateOneWithoutAssignmentsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  submissions: SubmissionUpdateManyWithoutAssignmentInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AssignmentUpdateManyMutationInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AssignmentUpdateManyWithWhereWithoutCourseInput {
  data: AssignmentUpdateManyMutationInput!
  where: AssignmentScalarWhereInput!
}

input AssignmentUpdateManyWithoutCourseInput {
  connect: [AssignmentWhereUniqueInput!]
  connectOrCreate: [AssignmentCreateOrConnectWithoutCourseInput!]
  create: [AssignmentCreateWithoutCourseInput!]
  delete: [AssignmentWhereUniqueInput!]
  deleteMany: [AssignmentScalarWhereInput!]
  disconnect: [AssignmentWhereUniqueInput!]
  set: [AssignmentWhereUniqueInput!]
  update: [AssignmentUpdateWithWhereUniqueWithoutCourseInput!]
  updateMany: [AssignmentUpdateManyWithWhereWithoutCourseInput!]
  upsert: [AssignmentUpsertWithWhereUniqueWithoutCourseInput!]
}

input AssignmentUpdateOneWithoutAssignmentFilesInput {
  connect: AssignmentWhereUniqueInput
  connectOrCreate: AssignmentCreateOrConnectWithoutAssignmentFilesInput
  create: AssignmentCreateWithoutAssignmentFilesInput
  delete: Boolean
  disconnect: Boolean
  update: AssignmentUpdateWithoutAssignmentFilesInput
  upsert: AssignmentUpsertWithoutAssignmentFilesInput
}

input AssignmentUpdateOneWithoutSubmissionsInput {
  connect: AssignmentWhereUniqueInput
  connectOrCreate: AssignmentCreateOrConnectWithoutSubmissionsInput
  create: AssignmentCreateWithoutSubmissionsInput
  delete: Boolean
  disconnect: Boolean
  update: AssignmentUpdateWithoutSubmissionsInput
  upsert: AssignmentUpsertWithoutSubmissionsInput
}

input AssignmentUpdateWithWhereUniqueWithoutCourseInput {
  data: AssignmentUpdateWithoutCourseInput!
  where: AssignmentWhereUniqueInput!
}

input AssignmentUpdateWithoutAssignmentFilesInput {
  content: StringFieldUpdateOperationsInput
  course: CourseUpdateOneWithoutAssignmentsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  submissions: SubmissionUpdateManyWithoutAssignmentInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AssignmentUpdateWithoutCourseInput {
  assignmentFiles: AssignmentFileUpdateManyWithoutAssignmentInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  submissions: SubmissionUpdateManyWithoutAssignmentInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AssignmentUpdateWithoutSubmissionsInput {
  assignmentFiles: AssignmentFileUpdateManyWithoutAssignmentInput
  content: StringFieldUpdateOperationsInput
  course: CourseUpdateOneWithoutAssignmentsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AssignmentUpsertWithWhereUniqueWithoutCourseInput {
  create: AssignmentCreateWithoutCourseInput!
  update: AssignmentUpdateWithoutCourseInput!
  where: AssignmentWhereUniqueInput!
}

input AssignmentUpsertWithoutAssignmentFilesInput {
  create: AssignmentCreateWithoutAssignmentFilesInput!
  update: AssignmentUpdateWithoutAssignmentFilesInput!
}

input AssignmentUpsertWithoutSubmissionsInput {
  create: AssignmentCreateWithoutSubmissionsInput!
  update: AssignmentUpdateWithoutSubmissionsInput!
}

input AssignmentWhereInput {
  AND: [AssignmentWhereInput!]
  NOT: [AssignmentWhereInput!]
  OR: [AssignmentWhereInput!]
  assignmentFiles: AssignmentFileListRelationFilter
  content: StringFilter
  course: CourseRelationFilter
  courseId: IntNullableFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  id: IntFilter
  published: BoolFilter
  submissions: SubmissionListRelationFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input AssignmentWhereUniqueInput {
  id: Int
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

type Course {
  _count: CourseCount
  assignments(cursor: AssignmentWhereUniqueInput, distinct: [AssignmentScalarFieldEnum!], orderBy: [AssignmentOrderByWithRelationInput!], skip: Int, take: Int, where: AssignmentWhereInput): [Assignment!]!
  createdAt: DateTime!
  description: String
  grade: Int!
  id: Int!
  lessons(cursor: LessonWhereUniqueInput, distinct: [LessonScalarFieldEnum!], orderBy: [LessonOrderByWithRelationInput!], skip: Int, take: Int, where: LessonWhereInput): [Lesson!]!
  meetings(cursor: MeetingWhereUniqueInput, distinct: [MeetingScalarFieldEnum!], orderBy: [MeetingOrderByWithRelationInput!], skip: Int, take: Int, where: MeetingWhereInput): [Meeting!]!
  published: Boolean!
  teacher: Teacher
  teacherId: Int
  title: String!
  topic: Topic
  topicId: Int
  updatedAt: DateTime!
}

type CourseAvgAggregate {
  grade: Float
  id: Float
  teacherId: Float
  topicId: Float
}

input CourseAvgOrderByAggregateInput {
  grade: SortOrder
  id: SortOrder
  teacherId: SortOrder
  topicId: SortOrder
}

type CourseCount {
  assignments: Int!
  lessons: Int!
  meetings: Int!
}

type CourseCountAggregate {
  _all: Int!
  createdAt: Int!
  description: Int!
  grade: Int!
  id: Int!
  published: Int!
  teacherId: Int!
  title: Int!
  topicId: Int!
  updatedAt: Int!
}

input CourseCountOrderByAggregateInput {
  createdAt: SortOrder
  description: SortOrder
  grade: SortOrder
  id: SortOrder
  published: SortOrder
  teacherId: SortOrder
  title: SortOrder
  topicId: SortOrder
  updatedAt: SortOrder
}

input CourseCreateInput {
  assignments: AssignmentCreateNestedManyWithoutCourseInput
  createdAt: DateTime
  description: String
  grade: Int!
  lessons: LessonCreateNestedManyWithoutCourseInput
  meetings: MeetingCreateNestedManyWithoutCourseInput
  published: Boolean
  teacher: TeacherCreateNestedOneWithoutCoursesInput
  title: String!
  topic: TopicCreateNestedOneWithoutCoursesInput
  updatedAt: DateTime
}

input CourseCreateNestedManyWithoutTeacherInput {
  connect: [CourseWhereUniqueInput!]
  connectOrCreate: [CourseCreateOrConnectWithoutTeacherInput!]
  create: [CourseCreateWithoutTeacherInput!]
}

input CourseCreateNestedManyWithoutTopicInput {
  connect: [CourseWhereUniqueInput!]
  connectOrCreate: [CourseCreateOrConnectWithoutTopicInput!]
  create: [CourseCreateWithoutTopicInput!]
}

input CourseCreateNestedOneWithoutAssignmentsInput {
  connect: CourseWhereUniqueInput
  connectOrCreate: CourseCreateOrConnectWithoutAssignmentsInput
  create: CourseCreateWithoutAssignmentsInput
}

input CourseCreateNestedOneWithoutLessonsInput {
  connect: CourseWhereUniqueInput
  connectOrCreate: CourseCreateOrConnectWithoutLessonsInput
  create: CourseCreateWithoutLessonsInput
}

input CourseCreateNestedOneWithoutMeetingsInput {
  connect: CourseWhereUniqueInput
  connectOrCreate: CourseCreateOrConnectWithoutMeetingsInput
  create: CourseCreateWithoutMeetingsInput
}

input CourseCreateOrConnectWithoutAssignmentsInput {
  create: CourseCreateWithoutAssignmentsInput!
  where: CourseWhereUniqueInput!
}

input CourseCreateOrConnectWithoutLessonsInput {
  create: CourseCreateWithoutLessonsInput!
  where: CourseWhereUniqueInput!
}

input CourseCreateOrConnectWithoutMeetingsInput {
  create: CourseCreateWithoutMeetingsInput!
  where: CourseWhereUniqueInput!
}

input CourseCreateOrConnectWithoutTeacherInput {
  create: CourseCreateWithoutTeacherInput!
  where: CourseWhereUniqueInput!
}

input CourseCreateOrConnectWithoutTopicInput {
  create: CourseCreateWithoutTopicInput!
  where: CourseWhereUniqueInput!
}

input CourseCreateWithoutAssignmentsInput {
  createdAt: DateTime
  description: String
  grade: Int!
  lessons: LessonCreateNestedManyWithoutCourseInput
  meetings: MeetingCreateNestedManyWithoutCourseInput
  published: Boolean
  teacher: TeacherCreateNestedOneWithoutCoursesInput
  title: String!
  topic: TopicCreateNestedOneWithoutCoursesInput
  updatedAt: DateTime
}

input CourseCreateWithoutLessonsInput {
  assignments: AssignmentCreateNestedManyWithoutCourseInput
  createdAt: DateTime
  description: String
  grade: Int!
  meetings: MeetingCreateNestedManyWithoutCourseInput
  published: Boolean
  teacher: TeacherCreateNestedOneWithoutCoursesInput
  title: String!
  topic: TopicCreateNestedOneWithoutCoursesInput
  updatedAt: DateTime
}

input CourseCreateWithoutMeetingsInput {
  assignments: AssignmentCreateNestedManyWithoutCourseInput
  createdAt: DateTime
  description: String
  grade: Int!
  lessons: LessonCreateNestedManyWithoutCourseInput
  published: Boolean
  teacher: TeacherCreateNestedOneWithoutCoursesInput
  title: String!
  topic: TopicCreateNestedOneWithoutCoursesInput
  updatedAt: DateTime
}

input CourseCreateWithoutTeacherInput {
  assignments: AssignmentCreateNestedManyWithoutCourseInput
  createdAt: DateTime
  description: String
  grade: Int!
  lessons: LessonCreateNestedManyWithoutCourseInput
  meetings: MeetingCreateNestedManyWithoutCourseInput
  published: Boolean
  title: String!
  topic: TopicCreateNestedOneWithoutCoursesInput
  updatedAt: DateTime
}

input CourseCreateWithoutTopicInput {
  assignments: AssignmentCreateNestedManyWithoutCourseInput
  createdAt: DateTime
  description: String
  grade: Int!
  lessons: LessonCreateNestedManyWithoutCourseInput
  meetings: MeetingCreateNestedManyWithoutCourseInput
  published: Boolean
  teacher: TeacherCreateNestedOneWithoutCoursesInput
  title: String!
  updatedAt: DateTime
}

type CourseGroupBy {
  _avg: CourseAvgAggregate
  _count: CourseCountAggregate
  _max: CourseMaxAggregate
  _min: CourseMinAggregate
  _sum: CourseSumAggregate
  createdAt: DateTime!
  description: String
  grade: Int!
  id: Int!
  published: Boolean!
  teacherId: Int
  title: String!
  topicId: Int
  updatedAt: DateTime!
}

input CourseListRelationFilter {
  every: CourseWhereInput
  none: CourseWhereInput
  some: CourseWhereInput
}

type CourseMaxAggregate {
  createdAt: DateTime
  description: String
  grade: Int
  id: Int
  published: Boolean
  teacherId: Int
  title: String
  topicId: Int
  updatedAt: DateTime
}

input CourseMaxOrderByAggregateInput {
  createdAt: SortOrder
  description: SortOrder
  grade: SortOrder
  id: SortOrder
  published: SortOrder
  teacherId: SortOrder
  title: SortOrder
  topicId: SortOrder
  updatedAt: SortOrder
}

type CourseMinAggregate {
  createdAt: DateTime
  description: String
  grade: Int
  id: Int
  published: Boolean
  teacherId: Int
  title: String
  topicId: Int
  updatedAt: DateTime
}

input CourseMinOrderByAggregateInput {
  createdAt: SortOrder
  description: SortOrder
  grade: SortOrder
  id: SortOrder
  published: SortOrder
  teacherId: SortOrder
  title: SortOrder
  topicId: SortOrder
  updatedAt: SortOrder
}

input CourseOrderByRelationAggregateInput {
  _count: SortOrder
}

input CourseOrderByWithAggregationInput {
  _avg: CourseAvgOrderByAggregateInput
  _count: CourseCountOrderByAggregateInput
  _max: CourseMaxOrderByAggregateInput
  _min: CourseMinOrderByAggregateInput
  _sum: CourseSumOrderByAggregateInput
  createdAt: SortOrder
  description: SortOrder
  grade: SortOrder
  id: SortOrder
  published: SortOrder
  teacherId: SortOrder
  title: SortOrder
  topicId: SortOrder
  updatedAt: SortOrder
}

input CourseOrderByWithRelationInput {
  assignments: AssignmentOrderByRelationAggregateInput
  createdAt: SortOrder
  description: SortOrder
  grade: SortOrder
  id: SortOrder
  lessons: LessonOrderByRelationAggregateInput
  meetings: MeetingOrderByRelationAggregateInput
  published: SortOrder
  teacher: TeacherOrderByWithRelationInput
  teacherId: SortOrder
  title: SortOrder
  topic: TopicOrderByWithRelationInput
  topicId: SortOrder
  updatedAt: SortOrder
}

input CourseRelationFilter {
  is: CourseWhereInput
  isNot: CourseWhereInput
}

enum CourseScalarFieldEnum {
  createdAt
  description
  grade
  id
  published
  teacherId
  title
  topicId
  updatedAt
}

input CourseScalarWhereInput {
  AND: [CourseScalarWhereInput!]
  NOT: [CourseScalarWhereInput!]
  OR: [CourseScalarWhereInput!]
  createdAt: DateTimeFilter
  description: StringNullableFilter
  grade: IntFilter
  id: IntFilter
  published: BoolFilter
  teacherId: IntNullableFilter
  title: StringFilter
  topicId: IntNullableFilter
  updatedAt: DateTimeFilter
}

input CourseScalarWhereWithAggregatesInput {
  AND: [CourseScalarWhereWithAggregatesInput!]
  NOT: [CourseScalarWhereWithAggregatesInput!]
  OR: [CourseScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  description: StringNullableWithAggregatesFilter
  grade: IntWithAggregatesFilter
  id: IntWithAggregatesFilter
  published: BoolWithAggregatesFilter
  teacherId: IntNullableWithAggregatesFilter
  title: StringWithAggregatesFilter
  topicId: IntNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type CourseSumAggregate {
  grade: Int
  id: Int
  teacherId: Int
  topicId: Int
}

input CourseSumOrderByAggregateInput {
  grade: SortOrder
  id: SortOrder
  teacherId: SortOrder
  topicId: SortOrder
}

input CourseUpdateInput {
  assignments: AssignmentUpdateManyWithoutCourseInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  grade: IntFieldUpdateOperationsInput
  lessons: LessonUpdateManyWithoutCourseInput
  meetings: MeetingUpdateManyWithoutCourseInput
  published: BoolFieldUpdateOperationsInput
  teacher: TeacherUpdateOneWithoutCoursesInput
  title: StringFieldUpdateOperationsInput
  topic: TopicUpdateOneWithoutCoursesInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CourseUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  grade: IntFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CourseUpdateManyWithWhereWithoutTeacherInput {
  data: CourseUpdateManyMutationInput!
  where: CourseScalarWhereInput!
}

input CourseUpdateManyWithWhereWithoutTopicInput {
  data: CourseUpdateManyMutationInput!
  where: CourseScalarWhereInput!
}

input CourseUpdateManyWithoutTeacherInput {
  connect: [CourseWhereUniqueInput!]
  connectOrCreate: [CourseCreateOrConnectWithoutTeacherInput!]
  create: [CourseCreateWithoutTeacherInput!]
  delete: [CourseWhereUniqueInput!]
  deleteMany: [CourseScalarWhereInput!]
  disconnect: [CourseWhereUniqueInput!]
  set: [CourseWhereUniqueInput!]
  update: [CourseUpdateWithWhereUniqueWithoutTeacherInput!]
  updateMany: [CourseUpdateManyWithWhereWithoutTeacherInput!]
  upsert: [CourseUpsertWithWhereUniqueWithoutTeacherInput!]
}

input CourseUpdateManyWithoutTopicInput {
  connect: [CourseWhereUniqueInput!]
  connectOrCreate: [CourseCreateOrConnectWithoutTopicInput!]
  create: [CourseCreateWithoutTopicInput!]
  delete: [CourseWhereUniqueInput!]
  deleteMany: [CourseScalarWhereInput!]
  disconnect: [CourseWhereUniqueInput!]
  set: [CourseWhereUniqueInput!]
  update: [CourseUpdateWithWhereUniqueWithoutTopicInput!]
  updateMany: [CourseUpdateManyWithWhereWithoutTopicInput!]
  upsert: [CourseUpsertWithWhereUniqueWithoutTopicInput!]
}

input CourseUpdateOneWithoutAssignmentsInput {
  connect: CourseWhereUniqueInput
  connectOrCreate: CourseCreateOrConnectWithoutAssignmentsInput
  create: CourseCreateWithoutAssignmentsInput
  delete: Boolean
  disconnect: Boolean
  update: CourseUpdateWithoutAssignmentsInput
  upsert: CourseUpsertWithoutAssignmentsInput
}

input CourseUpdateOneWithoutLessonsInput {
  connect: CourseWhereUniqueInput
  connectOrCreate: CourseCreateOrConnectWithoutLessonsInput
  create: CourseCreateWithoutLessonsInput
  delete: Boolean
  disconnect: Boolean
  update: CourseUpdateWithoutLessonsInput
  upsert: CourseUpsertWithoutLessonsInput
}

input CourseUpdateOneWithoutMeetingsInput {
  connect: CourseWhereUniqueInput
  connectOrCreate: CourseCreateOrConnectWithoutMeetingsInput
  create: CourseCreateWithoutMeetingsInput
  delete: Boolean
  disconnect: Boolean
  update: CourseUpdateWithoutMeetingsInput
  upsert: CourseUpsertWithoutMeetingsInput
}

input CourseUpdateWithWhereUniqueWithoutTeacherInput {
  data: CourseUpdateWithoutTeacherInput!
  where: CourseWhereUniqueInput!
}

input CourseUpdateWithWhereUniqueWithoutTopicInput {
  data: CourseUpdateWithoutTopicInput!
  where: CourseWhereUniqueInput!
}

input CourseUpdateWithoutAssignmentsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  grade: IntFieldUpdateOperationsInput
  lessons: LessonUpdateManyWithoutCourseInput
  meetings: MeetingUpdateManyWithoutCourseInput
  published: BoolFieldUpdateOperationsInput
  teacher: TeacherUpdateOneWithoutCoursesInput
  title: StringFieldUpdateOperationsInput
  topic: TopicUpdateOneWithoutCoursesInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CourseUpdateWithoutLessonsInput {
  assignments: AssignmentUpdateManyWithoutCourseInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  grade: IntFieldUpdateOperationsInput
  meetings: MeetingUpdateManyWithoutCourseInput
  published: BoolFieldUpdateOperationsInput
  teacher: TeacherUpdateOneWithoutCoursesInput
  title: StringFieldUpdateOperationsInput
  topic: TopicUpdateOneWithoutCoursesInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CourseUpdateWithoutMeetingsInput {
  assignments: AssignmentUpdateManyWithoutCourseInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  grade: IntFieldUpdateOperationsInput
  lessons: LessonUpdateManyWithoutCourseInput
  published: BoolFieldUpdateOperationsInput
  teacher: TeacherUpdateOneWithoutCoursesInput
  title: StringFieldUpdateOperationsInput
  topic: TopicUpdateOneWithoutCoursesInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CourseUpdateWithoutTeacherInput {
  assignments: AssignmentUpdateManyWithoutCourseInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  grade: IntFieldUpdateOperationsInput
  lessons: LessonUpdateManyWithoutCourseInput
  meetings: MeetingUpdateManyWithoutCourseInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  topic: TopicUpdateOneWithoutCoursesInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CourseUpdateWithoutTopicInput {
  assignments: AssignmentUpdateManyWithoutCourseInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  grade: IntFieldUpdateOperationsInput
  lessons: LessonUpdateManyWithoutCourseInput
  meetings: MeetingUpdateManyWithoutCourseInput
  published: BoolFieldUpdateOperationsInput
  teacher: TeacherUpdateOneWithoutCoursesInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input CourseUpsertWithWhereUniqueWithoutTeacherInput {
  create: CourseCreateWithoutTeacherInput!
  update: CourseUpdateWithoutTeacherInput!
  where: CourseWhereUniqueInput!
}

input CourseUpsertWithWhereUniqueWithoutTopicInput {
  create: CourseCreateWithoutTopicInput!
  update: CourseUpdateWithoutTopicInput!
  where: CourseWhereUniqueInput!
}

input CourseUpsertWithoutAssignmentsInput {
  create: CourseCreateWithoutAssignmentsInput!
  update: CourseUpdateWithoutAssignmentsInput!
}

input CourseUpsertWithoutLessonsInput {
  create: CourseCreateWithoutLessonsInput!
  update: CourseUpdateWithoutLessonsInput!
}

input CourseUpsertWithoutMeetingsInput {
  create: CourseCreateWithoutMeetingsInput!
  update: CourseUpdateWithoutMeetingsInput!
}

input CourseWhereInput {
  AND: [CourseWhereInput!]
  NOT: [CourseWhereInput!]
  OR: [CourseWhereInput!]
  assignments: AssignmentListRelationFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  grade: IntFilter
  id: IntFilter
  lessons: LessonListRelationFilter
  meetings: MeetingListRelationFilter
  published: BoolFilter
  teacher: TeacherRelationFilter
  teacherId: IntNullableFilter
  title: StringFilter
  topic: TopicRelationFilter
  topicId: IntNullableFilter
  updatedAt: DateTimeFilter
}

input CourseWhereUniqueInput {
  id: Int
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

type Department {
  _count: DepartmentCount
  id: Int!
  name: String!
  topics(cursor: TopicWhereUniqueInput, distinct: [TopicScalarFieldEnum!], orderBy: [TopicOrderByWithRelationInput!], skip: Int, take: Int, where: TopicWhereInput): [Topic!]!
}

type DepartmentAvgAggregate {
  id: Float
}

input DepartmentAvgOrderByAggregateInput {
  id: SortOrder
}

type DepartmentCount {
  topics: Int!
}

type DepartmentCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
}

input DepartmentCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input DepartmentCreateInput {
  name: String!
  topics: TopicCreateNestedManyWithoutDepartmentInput
}

input DepartmentCreateNestedOneWithoutTopicsInput {
  connect: DepartmentWhereUniqueInput
  connectOrCreate: DepartmentCreateOrConnectWithoutTopicsInput
  create: DepartmentCreateWithoutTopicsInput
}

input DepartmentCreateOrConnectWithoutTopicsInput {
  create: DepartmentCreateWithoutTopicsInput!
  where: DepartmentWhereUniqueInput!
}

input DepartmentCreateWithoutTopicsInput {
  name: String!
}

type DepartmentGroupBy {
  _avg: DepartmentAvgAggregate
  _count: DepartmentCountAggregate
  _max: DepartmentMaxAggregate
  _min: DepartmentMinAggregate
  _sum: DepartmentSumAggregate
  id: Int!
  name: String!
}

type DepartmentMaxAggregate {
  id: Int
  name: String
}

input DepartmentMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

type DepartmentMinAggregate {
  id: Int
  name: String
}

input DepartmentMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input DepartmentOrderByWithAggregationInput {
  _avg: DepartmentAvgOrderByAggregateInput
  _count: DepartmentCountOrderByAggregateInput
  _max: DepartmentMaxOrderByAggregateInput
  _min: DepartmentMinOrderByAggregateInput
  _sum: DepartmentSumOrderByAggregateInput
  id: SortOrder
  name: SortOrder
}

input DepartmentOrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
  topics: TopicOrderByRelationAggregateInput
}

input DepartmentRelationFilter {
  is: DepartmentWhereInput
  isNot: DepartmentWhereInput
}

enum DepartmentScalarFieldEnum {
  id
  name
}

input DepartmentScalarWhereWithAggregatesInput {
  AND: [DepartmentScalarWhereWithAggregatesInput!]
  NOT: [DepartmentScalarWhereWithAggregatesInput!]
  OR: [DepartmentScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type DepartmentSumAggregate {
  id: Int
}

input DepartmentSumOrderByAggregateInput {
  id: SortOrder
}

input DepartmentUpdateInput {
  name: StringFieldUpdateOperationsInput
  topics: TopicUpdateManyWithoutDepartmentInput
}

input DepartmentUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
}

input DepartmentUpdateOneWithoutTopicsInput {
  connect: DepartmentWhereUniqueInput
  connectOrCreate: DepartmentCreateOrConnectWithoutTopicsInput
  create: DepartmentCreateWithoutTopicsInput
  delete: Boolean
  disconnect: Boolean
  update: DepartmentUpdateWithoutTopicsInput
  upsert: DepartmentUpsertWithoutTopicsInput
}

input DepartmentUpdateWithoutTopicsInput {
  name: StringFieldUpdateOperationsInput
}

input DepartmentUpsertWithoutTopicsInput {
  create: DepartmentCreateWithoutTopicsInput!
  update: DepartmentUpdateWithoutTopicsInput!
}

input DepartmentWhereInput {
  AND: [DepartmentWhereInput!]
  NOT: [DepartmentWhereInput!]
  OR: [DepartmentWhereInput!]
  id: IntFilter
  name: StringFilter
  topics: TopicListRelationFilter
}

input DepartmentWhereUniqueInput {
  id: Int
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Lesson {
  _count: LessonCount
  content: String!
  course: Course
  courseId: Int
  createdAt: DateTime!
  description: String
  id: Int!
  lessonFiles(cursor: LessonFileWhereUniqueInput, distinct: [LessonFileScalarFieldEnum!], orderBy: [LessonFileOrderByWithRelationInput!], skip: Int, take: Int, where: LessonFileWhereInput): [LessonFile!]!
  published: Boolean!
  title: String!
  updatedAt: DateTime!
}

type LessonAvgAggregate {
  courseId: Float
  id: Float
}

input LessonAvgOrderByAggregateInput {
  courseId: SortOrder
  id: SortOrder
}

type LessonCount {
  lessonFiles: Int!
}

type LessonCountAggregate {
  _all: Int!
  content: Int!
  courseId: Int!
  createdAt: Int!
  description: Int!
  id: Int!
  published: Int!
  title: Int!
  updatedAt: Int!
}

input LessonCountOrderByAggregateInput {
  content: SortOrder
  courseId: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  published: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input LessonCreateInput {
  content: String!
  course: CourseCreateNestedOneWithoutLessonsInput
  createdAt: DateTime
  description: String
  lessonFiles: LessonFileCreateNestedManyWithoutLessonInput
  published: Boolean!
  title: String!
  updatedAt: DateTime
}

input LessonCreateNestedManyWithoutCourseInput {
  connect: [LessonWhereUniqueInput!]
  connectOrCreate: [LessonCreateOrConnectWithoutCourseInput!]
  create: [LessonCreateWithoutCourseInput!]
}

input LessonCreateNestedOneWithoutLessonFilesInput {
  connect: LessonWhereUniqueInput
  connectOrCreate: LessonCreateOrConnectWithoutLessonFilesInput
  create: LessonCreateWithoutLessonFilesInput
}

input LessonCreateOrConnectWithoutCourseInput {
  create: LessonCreateWithoutCourseInput!
  where: LessonWhereUniqueInput!
}

input LessonCreateOrConnectWithoutLessonFilesInput {
  create: LessonCreateWithoutLessonFilesInput!
  where: LessonWhereUniqueInput!
}

input LessonCreateWithoutCourseInput {
  content: String!
  createdAt: DateTime
  description: String
  lessonFiles: LessonFileCreateNestedManyWithoutLessonInput
  published: Boolean!
  title: String!
  updatedAt: DateTime
}

input LessonCreateWithoutLessonFilesInput {
  content: String!
  course: CourseCreateNestedOneWithoutLessonsInput
  createdAt: DateTime
  description: String
  published: Boolean!
  title: String!
  updatedAt: DateTime
}

type LessonFile {
  createdAt: DateTime!
  id: Int!
  lesson: Lesson
  lessonId: Int
  link: String!
  name: String!
  type: String!
  updatedAt: DateTime!
}

type LessonFileAvgAggregate {
  id: Float
  lessonId: Float
}

input LessonFileAvgOrderByAggregateInput {
  id: SortOrder
  lessonId: SortOrder
}

type LessonFileCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  lessonId: Int!
  link: Int!
  name: Int!
  type: Int!
  updatedAt: Int!
}

input LessonFileCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  lessonId: SortOrder
  link: SortOrder
  name: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

input LessonFileCreateInput {
  createdAt: DateTime
  lesson: LessonCreateNestedOneWithoutLessonFilesInput
  link: String!
  name: String!
  type: String!
  updatedAt: DateTime
}

input LessonFileCreateNestedManyWithoutLessonInput {
  connect: [LessonFileWhereUniqueInput!]
  connectOrCreate: [LessonFileCreateOrConnectWithoutLessonInput!]
  create: [LessonFileCreateWithoutLessonInput!]
}

input LessonFileCreateOrConnectWithoutLessonInput {
  create: LessonFileCreateWithoutLessonInput!
  where: LessonFileWhereUniqueInput!
}

input LessonFileCreateWithoutLessonInput {
  createdAt: DateTime
  link: String!
  name: String!
  type: String!
  updatedAt: DateTime
}

type LessonFileGroupBy {
  _avg: LessonFileAvgAggregate
  _count: LessonFileCountAggregate
  _max: LessonFileMaxAggregate
  _min: LessonFileMinAggregate
  _sum: LessonFileSumAggregate
  createdAt: DateTime!
  id: Int!
  lessonId: Int
  link: String!
  name: String!
  type: String!
  updatedAt: DateTime!
}

input LessonFileListRelationFilter {
  every: LessonFileWhereInput
  none: LessonFileWhereInput
  some: LessonFileWhereInput
}

type LessonFileMaxAggregate {
  createdAt: DateTime
  id: Int
  lessonId: Int
  link: String
  name: String
  type: String
  updatedAt: DateTime
}

input LessonFileMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  lessonId: SortOrder
  link: SortOrder
  name: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

type LessonFileMinAggregate {
  createdAt: DateTime
  id: Int
  lessonId: Int
  link: String
  name: String
  type: String
  updatedAt: DateTime
}

input LessonFileMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  lessonId: SortOrder
  link: SortOrder
  name: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

input LessonFileOrderByRelationAggregateInput {
  _count: SortOrder
}

input LessonFileOrderByWithAggregationInput {
  _avg: LessonFileAvgOrderByAggregateInput
  _count: LessonFileCountOrderByAggregateInput
  _max: LessonFileMaxOrderByAggregateInput
  _min: LessonFileMinOrderByAggregateInput
  _sum: LessonFileSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  lessonId: SortOrder
  link: SortOrder
  name: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

input LessonFileOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  lesson: LessonOrderByWithRelationInput
  lessonId: SortOrder
  link: SortOrder
  name: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

enum LessonFileScalarFieldEnum {
  createdAt
  id
  lessonId
  link
  name
  type
  updatedAt
}

input LessonFileScalarWhereInput {
  AND: [LessonFileScalarWhereInput!]
  NOT: [LessonFileScalarWhereInput!]
  OR: [LessonFileScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  lessonId: IntNullableFilter
  link: StringFilter
  name: StringFilter
  type: StringFilter
  updatedAt: DateTimeFilter
}

input LessonFileScalarWhereWithAggregatesInput {
  AND: [LessonFileScalarWhereWithAggregatesInput!]
  NOT: [LessonFileScalarWhereWithAggregatesInput!]
  OR: [LessonFileScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  lessonId: IntNullableWithAggregatesFilter
  link: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  type: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type LessonFileSumAggregate {
  id: Int
  lessonId: Int
}

input LessonFileSumOrderByAggregateInput {
  id: SortOrder
  lessonId: SortOrder
}

input LessonFileUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  lesson: LessonUpdateOneWithoutLessonFilesInput
  link: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LessonFileUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  link: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LessonFileUpdateManyWithWhereWithoutLessonInput {
  data: LessonFileUpdateManyMutationInput!
  where: LessonFileScalarWhereInput!
}

input LessonFileUpdateManyWithoutLessonInput {
  connect: [LessonFileWhereUniqueInput!]
  connectOrCreate: [LessonFileCreateOrConnectWithoutLessonInput!]
  create: [LessonFileCreateWithoutLessonInput!]
  delete: [LessonFileWhereUniqueInput!]
  deleteMany: [LessonFileScalarWhereInput!]
  disconnect: [LessonFileWhereUniqueInput!]
  set: [LessonFileWhereUniqueInput!]
  update: [LessonFileUpdateWithWhereUniqueWithoutLessonInput!]
  updateMany: [LessonFileUpdateManyWithWhereWithoutLessonInput!]
  upsert: [LessonFileUpsertWithWhereUniqueWithoutLessonInput!]
}

input LessonFileUpdateWithWhereUniqueWithoutLessonInput {
  data: LessonFileUpdateWithoutLessonInput!
  where: LessonFileWhereUniqueInput!
}

input LessonFileUpdateWithoutLessonInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  link: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LessonFileUpsertWithWhereUniqueWithoutLessonInput {
  create: LessonFileCreateWithoutLessonInput!
  update: LessonFileUpdateWithoutLessonInput!
  where: LessonFileWhereUniqueInput!
}

input LessonFileWhereInput {
  AND: [LessonFileWhereInput!]
  NOT: [LessonFileWhereInput!]
  OR: [LessonFileWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  lesson: LessonRelationFilter
  lessonId: IntNullableFilter
  link: StringFilter
  name: StringFilter
  type: StringFilter
  updatedAt: DateTimeFilter
}

input LessonFileWhereUniqueInput {
  id: Int
}

type LessonGroupBy {
  _avg: LessonAvgAggregate
  _count: LessonCountAggregate
  _max: LessonMaxAggregate
  _min: LessonMinAggregate
  _sum: LessonSumAggregate
  content: String!
  courseId: Int
  createdAt: DateTime!
  description: String
  id: Int!
  published: Boolean!
  title: String!
  updatedAt: DateTime!
}

input LessonListRelationFilter {
  every: LessonWhereInput
  none: LessonWhereInput
  some: LessonWhereInput
}

type LessonMaxAggregate {
  content: String
  courseId: Int
  createdAt: DateTime
  description: String
  id: Int
  published: Boolean
  title: String
  updatedAt: DateTime
}

input LessonMaxOrderByAggregateInput {
  content: SortOrder
  courseId: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  published: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

type LessonMinAggregate {
  content: String
  courseId: Int
  createdAt: DateTime
  description: String
  id: Int
  published: Boolean
  title: String
  updatedAt: DateTime
}

input LessonMinOrderByAggregateInput {
  content: SortOrder
  courseId: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  published: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input LessonOrderByRelationAggregateInput {
  _count: SortOrder
}

input LessonOrderByWithAggregationInput {
  _avg: LessonAvgOrderByAggregateInput
  _count: LessonCountOrderByAggregateInput
  _max: LessonMaxOrderByAggregateInput
  _min: LessonMinOrderByAggregateInput
  _sum: LessonSumOrderByAggregateInput
  content: SortOrder
  courseId: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  published: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input LessonOrderByWithRelationInput {
  content: SortOrder
  course: CourseOrderByWithRelationInput
  courseId: SortOrder
  createdAt: SortOrder
  description: SortOrder
  id: SortOrder
  lessonFiles: LessonFileOrderByRelationAggregateInput
  published: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input LessonRelationFilter {
  is: LessonWhereInput
  isNot: LessonWhereInput
}

enum LessonScalarFieldEnum {
  content
  courseId
  createdAt
  description
  id
  published
  title
  updatedAt
}

input LessonScalarWhereInput {
  AND: [LessonScalarWhereInput!]
  NOT: [LessonScalarWhereInput!]
  OR: [LessonScalarWhereInput!]
  content: StringFilter
  courseId: IntNullableFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  id: IntFilter
  published: BoolFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input LessonScalarWhereWithAggregatesInput {
  AND: [LessonScalarWhereWithAggregatesInput!]
  NOT: [LessonScalarWhereWithAggregatesInput!]
  OR: [LessonScalarWhereWithAggregatesInput!]
  content: StringWithAggregatesFilter
  courseId: IntNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  description: StringNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  published: BoolWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type LessonSumAggregate {
  courseId: Int
  id: Int
}

input LessonSumOrderByAggregateInput {
  courseId: SortOrder
  id: SortOrder
}

input LessonUpdateInput {
  content: StringFieldUpdateOperationsInput
  course: CourseUpdateOneWithoutLessonsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  lessonFiles: LessonFileUpdateManyWithoutLessonInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LessonUpdateManyMutationInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LessonUpdateManyWithWhereWithoutCourseInput {
  data: LessonUpdateManyMutationInput!
  where: LessonScalarWhereInput!
}

input LessonUpdateManyWithoutCourseInput {
  connect: [LessonWhereUniqueInput!]
  connectOrCreate: [LessonCreateOrConnectWithoutCourseInput!]
  create: [LessonCreateWithoutCourseInput!]
  delete: [LessonWhereUniqueInput!]
  deleteMany: [LessonScalarWhereInput!]
  disconnect: [LessonWhereUniqueInput!]
  set: [LessonWhereUniqueInput!]
  update: [LessonUpdateWithWhereUniqueWithoutCourseInput!]
  updateMany: [LessonUpdateManyWithWhereWithoutCourseInput!]
  upsert: [LessonUpsertWithWhereUniqueWithoutCourseInput!]
}

input LessonUpdateOneWithoutLessonFilesInput {
  connect: LessonWhereUniqueInput
  connectOrCreate: LessonCreateOrConnectWithoutLessonFilesInput
  create: LessonCreateWithoutLessonFilesInput
  delete: Boolean
  disconnect: Boolean
  update: LessonUpdateWithoutLessonFilesInput
  upsert: LessonUpsertWithoutLessonFilesInput
}

input LessonUpdateWithWhereUniqueWithoutCourseInput {
  data: LessonUpdateWithoutCourseInput!
  where: LessonWhereUniqueInput!
}

input LessonUpdateWithoutCourseInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  lessonFiles: LessonFileUpdateManyWithoutLessonInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LessonUpdateWithoutLessonFilesInput {
  content: StringFieldUpdateOperationsInput
  course: CourseUpdateOneWithoutLessonsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  published: BoolFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input LessonUpsertWithWhereUniqueWithoutCourseInput {
  create: LessonCreateWithoutCourseInput!
  update: LessonUpdateWithoutCourseInput!
  where: LessonWhereUniqueInput!
}

input LessonUpsertWithoutLessonFilesInput {
  create: LessonCreateWithoutLessonFilesInput!
  update: LessonUpdateWithoutLessonFilesInput!
}

input LessonWhereInput {
  AND: [LessonWhereInput!]
  NOT: [LessonWhereInput!]
  OR: [LessonWhereInput!]
  content: StringFilter
  course: CourseRelationFilter
  courseId: IntNullableFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  id: IntFilter
  lessonFiles: LessonFileListRelationFilter
  published: BoolFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input LessonWhereUniqueInput {
  id: Int
}

type Meeting {
  course: Course
  courseId: Int
  createdAt: DateTime!
  date: DateTime!
  description: String
  duration: DateTime!
  id: Int!
  link: String
  startTime: DateTime!
  title: String!
  updatedAt: DateTime!
}

type MeetingAvgAggregate {
  courseId: Float
  id: Float
}

input MeetingAvgOrderByAggregateInput {
  courseId: SortOrder
  id: SortOrder
}

type MeetingCountAggregate {
  _all: Int!
  courseId: Int!
  createdAt: Int!
  date: Int!
  description: Int!
  duration: Int!
  id: Int!
  link: Int!
  startTime: Int!
  title: Int!
  updatedAt: Int!
}

input MeetingCountOrderByAggregateInput {
  courseId: SortOrder
  createdAt: SortOrder
  date: SortOrder
  description: SortOrder
  duration: SortOrder
  id: SortOrder
  link: SortOrder
  startTime: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input MeetingCreateInput {
  course: CourseCreateNestedOneWithoutMeetingsInput
  createdAt: DateTime
  date: DateTime!
  description: String
  duration: DateTime!
  link: String
  startTime: DateTime!
  title: String!
  updatedAt: DateTime
}

input MeetingCreateNestedManyWithoutCourseInput {
  connect: [MeetingWhereUniqueInput!]
  connectOrCreate: [MeetingCreateOrConnectWithoutCourseInput!]
  create: [MeetingCreateWithoutCourseInput!]
}

input MeetingCreateOrConnectWithoutCourseInput {
  create: MeetingCreateWithoutCourseInput!
  where: MeetingWhereUniqueInput!
}

input MeetingCreateWithoutCourseInput {
  createdAt: DateTime
  date: DateTime!
  description: String
  duration: DateTime!
  link: String
  startTime: DateTime!
  title: String!
  updatedAt: DateTime
}

type MeetingGroupBy {
  _avg: MeetingAvgAggregate
  _count: MeetingCountAggregate
  _max: MeetingMaxAggregate
  _min: MeetingMinAggregate
  _sum: MeetingSumAggregate
  courseId: Int
  createdAt: DateTime!
  date: DateTime!
  description: String
  duration: DateTime!
  id: Int!
  link: String
  startTime: DateTime!
  title: String!
  updatedAt: DateTime!
}

input MeetingListRelationFilter {
  every: MeetingWhereInput
  none: MeetingWhereInput
  some: MeetingWhereInput
}

type MeetingMaxAggregate {
  courseId: Int
  createdAt: DateTime
  date: DateTime
  description: String
  duration: DateTime
  id: Int
  link: String
  startTime: DateTime
  title: String
  updatedAt: DateTime
}

input MeetingMaxOrderByAggregateInput {
  courseId: SortOrder
  createdAt: SortOrder
  date: SortOrder
  description: SortOrder
  duration: SortOrder
  id: SortOrder
  link: SortOrder
  startTime: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

type MeetingMinAggregate {
  courseId: Int
  createdAt: DateTime
  date: DateTime
  description: String
  duration: DateTime
  id: Int
  link: String
  startTime: DateTime
  title: String
  updatedAt: DateTime
}

input MeetingMinOrderByAggregateInput {
  courseId: SortOrder
  createdAt: SortOrder
  date: SortOrder
  description: SortOrder
  duration: SortOrder
  id: SortOrder
  link: SortOrder
  startTime: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input MeetingOrderByRelationAggregateInput {
  _count: SortOrder
}

input MeetingOrderByWithAggregationInput {
  _avg: MeetingAvgOrderByAggregateInput
  _count: MeetingCountOrderByAggregateInput
  _max: MeetingMaxOrderByAggregateInput
  _min: MeetingMinOrderByAggregateInput
  _sum: MeetingSumOrderByAggregateInput
  courseId: SortOrder
  createdAt: SortOrder
  date: SortOrder
  description: SortOrder
  duration: SortOrder
  id: SortOrder
  link: SortOrder
  startTime: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input MeetingOrderByWithRelationInput {
  course: CourseOrderByWithRelationInput
  courseId: SortOrder
  createdAt: SortOrder
  date: SortOrder
  description: SortOrder
  duration: SortOrder
  id: SortOrder
  link: SortOrder
  startTime: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

enum MeetingScalarFieldEnum {
  courseId
  createdAt
  date
  description
  duration
  id
  link
  startTime
  title
  updatedAt
}

input MeetingScalarWhereInput {
  AND: [MeetingScalarWhereInput!]
  NOT: [MeetingScalarWhereInput!]
  OR: [MeetingScalarWhereInput!]
  courseId: IntNullableFilter
  createdAt: DateTimeFilter
  date: DateTimeFilter
  description: StringNullableFilter
  duration: DateTimeFilter
  id: IntFilter
  link: StringNullableFilter
  startTime: DateTimeFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input MeetingScalarWhereWithAggregatesInput {
  AND: [MeetingScalarWhereWithAggregatesInput!]
  NOT: [MeetingScalarWhereWithAggregatesInput!]
  OR: [MeetingScalarWhereWithAggregatesInput!]
  courseId: IntNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  date: DateTimeWithAggregatesFilter
  description: StringNullableWithAggregatesFilter
  duration: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  link: StringNullableWithAggregatesFilter
  startTime: DateTimeWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type MeetingSumAggregate {
  courseId: Int
  id: Int
}

input MeetingSumOrderByAggregateInput {
  courseId: SortOrder
  id: SortOrder
}

input MeetingUpdateInput {
  course: CourseUpdateOneWithoutMeetingsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  duration: DateTimeFieldUpdateOperationsInput
  link: NullableStringFieldUpdateOperationsInput
  startTime: DateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input MeetingUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  duration: DateTimeFieldUpdateOperationsInput
  link: NullableStringFieldUpdateOperationsInput
  startTime: DateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input MeetingUpdateManyWithWhereWithoutCourseInput {
  data: MeetingUpdateManyMutationInput!
  where: MeetingScalarWhereInput!
}

input MeetingUpdateManyWithoutCourseInput {
  connect: [MeetingWhereUniqueInput!]
  connectOrCreate: [MeetingCreateOrConnectWithoutCourseInput!]
  create: [MeetingCreateWithoutCourseInput!]
  delete: [MeetingWhereUniqueInput!]
  deleteMany: [MeetingScalarWhereInput!]
  disconnect: [MeetingWhereUniqueInput!]
  set: [MeetingWhereUniqueInput!]
  update: [MeetingUpdateWithWhereUniqueWithoutCourseInput!]
  updateMany: [MeetingUpdateManyWithWhereWithoutCourseInput!]
  upsert: [MeetingUpsertWithWhereUniqueWithoutCourseInput!]
}

input MeetingUpdateWithWhereUniqueWithoutCourseInput {
  data: MeetingUpdateWithoutCourseInput!
  where: MeetingWhereUniqueInput!
}

input MeetingUpdateWithoutCourseInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  duration: DateTimeFieldUpdateOperationsInput
  link: NullableStringFieldUpdateOperationsInput
  startTime: DateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input MeetingUpsertWithWhereUniqueWithoutCourseInput {
  create: MeetingCreateWithoutCourseInput!
  update: MeetingUpdateWithoutCourseInput!
  where: MeetingWhereUniqueInput!
}

input MeetingWhereInput {
  AND: [MeetingWhereInput!]
  NOT: [MeetingWhereInput!]
  OR: [MeetingWhereInput!]
  course: CourseRelationFilter
  courseId: IntNullableFilter
  createdAt: DateTimeFilter
  date: DateTimeFilter
  description: StringNullableFilter
  duration: DateTimeFilter
  id: IntFilter
  link: StringNullableFilter
  startTime: DateTimeFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input MeetingWhereUniqueInput {
  id: Int
}

type Mutation {
  createAdmin(data: AdminCreateInput!): Admin!
  createAssignment(data: AssignmentCreateInput!): Assignment!
  createAssignmentFile(data: AssignmentFileCreateInput!): AssignmentFile!
  createCourse(data: CourseCreateInput!): Course!
  createDepartment(data: DepartmentCreateInput!): Department!
  createLesson(data: LessonCreateInput!): Lesson!
  createLessonFile(data: LessonFileCreateInput!): LessonFile!
  createMeeting(data: MeetingCreateInput!): Meeting!
  createStudent(data: StudentCreateInput!): Student!
  createSubmission(data: SubmissionCreateInput!): Submission!
  createSubmissionFile(data: SubmissionFileCreateInput!): SubmissionFile!
  createTeacher(data: TeacherCreateInput!): Teacher!
  createTopic(data: TopicCreateInput!): Topic!
  createUser(data: UserCreateInput!): User!
  deleteAdmin(where: AdminWhereUniqueInput!): Admin
  deleteAssignment(where: AssignmentWhereUniqueInput!): Assignment
  deleteAssignmentFile(where: AssignmentFileWhereUniqueInput!): AssignmentFile
  deleteCourse(where: CourseWhereUniqueInput!): Course
  deleteDepartment(where: DepartmentWhereUniqueInput!): Department
  deleteLesson(where: LessonWhereUniqueInput!): Lesson
  deleteLessonFile(where: LessonFileWhereUniqueInput!): LessonFile
  deleteManyAdmin(where: AdminWhereInput): AffectedRowsOutput!
  deleteManyAssignment(where: AssignmentWhereInput): AffectedRowsOutput!
  deleteManyAssignmentFile(where: AssignmentFileWhereInput): AffectedRowsOutput!
  deleteManyCourse(where: CourseWhereInput): AffectedRowsOutput!
  deleteManyDepartment(where: DepartmentWhereInput): AffectedRowsOutput!
  deleteManyLesson(where: LessonWhereInput): AffectedRowsOutput!
  deleteManyLessonFile(where: LessonFileWhereInput): AffectedRowsOutput!
  deleteManyMeeting(where: MeetingWhereInput): AffectedRowsOutput!
  deleteManyStudent(where: StudentWhereInput): AffectedRowsOutput!
  deleteManySubmission(where: SubmissionWhereInput): AffectedRowsOutput!
  deleteManySubmissionFile(where: SubmissionFileWhereInput): AffectedRowsOutput!
  deleteManyTeacher(where: TeacherWhereInput): AffectedRowsOutput!
  deleteManyTopic(where: TopicWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteMeeting(where: MeetingWhereUniqueInput!): Meeting
  deleteStudent(where: StudentWhereUniqueInput!): Student
  deleteSubmission(where: SubmissionWhereUniqueInput!): Submission
  deleteSubmissionFile(where: SubmissionFileWhereUniqueInput!): SubmissionFile
  deleteTeacher(where: TeacherWhereUniqueInput!): Teacher
  deleteTopic(where: TopicWhereUniqueInput!): Topic
  deleteUser(where: UserWhereUniqueInput!): User
  updateAdmin(data: AdminUpdateInput!, where: AdminWhereUniqueInput!): Admin
  updateAssignment(data: AssignmentUpdateInput!, where: AssignmentWhereUniqueInput!): Assignment
  updateAssignmentFile(data: AssignmentFileUpdateInput!, where: AssignmentFileWhereUniqueInput!): AssignmentFile
  updateCourse(data: CourseUpdateInput!, where: CourseWhereUniqueInput!): Course
  updateDepartment(data: DepartmentUpdateInput!, where: DepartmentWhereUniqueInput!): Department
  updateLesson(data: LessonUpdateInput!, where: LessonWhereUniqueInput!): Lesson
  updateLessonFile(data: LessonFileUpdateInput!, where: LessonFileWhereUniqueInput!): LessonFile
  updateManyAdmin(data: AdminUpdateManyMutationInput!, where: AdminWhereInput): AffectedRowsOutput!
  updateManyAssignment(data: AssignmentUpdateManyMutationInput!, where: AssignmentWhereInput): AffectedRowsOutput!
  updateManyAssignmentFile(data: AssignmentFileUpdateManyMutationInput!, where: AssignmentFileWhereInput): AffectedRowsOutput!
  updateManyCourse(data: CourseUpdateManyMutationInput!, where: CourseWhereInput): AffectedRowsOutput!
  updateManyDepartment(data: DepartmentUpdateManyMutationInput!, where: DepartmentWhereInput): AffectedRowsOutput!
  updateManyLesson(data: LessonUpdateManyMutationInput!, where: LessonWhereInput): AffectedRowsOutput!
  updateManyLessonFile(data: LessonFileUpdateManyMutationInput!, where: LessonFileWhereInput): AffectedRowsOutput!
  updateManyMeeting(data: MeetingUpdateManyMutationInput!, where: MeetingWhereInput): AffectedRowsOutput!
  updateManyStudent(data: StudentUpdateManyMutationInput!, where: StudentWhereInput): AffectedRowsOutput!
  updateManySubmission(data: SubmissionUpdateManyMutationInput!, where: SubmissionWhereInput): AffectedRowsOutput!
  updateManySubmissionFile(data: SubmissionFileUpdateManyMutationInput!, where: SubmissionFileWhereInput): AffectedRowsOutput!
  updateManyTeacher(data: TeacherUpdateManyMutationInput!, where: TeacherWhereInput): AffectedRowsOutput!
  updateManyTopic(data: TopicUpdateManyMutationInput!, where: TopicWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateMeeting(data: MeetingUpdateInput!, where: MeetingWhereUniqueInput!): Meeting
  updateStudent(data: StudentUpdateInput!, where: StudentWhereUniqueInput!): Student
  updateSubmission(data: SubmissionUpdateInput!, where: SubmissionWhereUniqueInput!): Submission
  updateSubmissionFile(data: SubmissionFileUpdateInput!, where: SubmissionFileWhereUniqueInput!): SubmissionFile
  updateTeacher(data: TeacherUpdateInput!, where: TeacherWhereUniqueInput!): Teacher
  updateTopic(data: TopicUpdateInput!, where: TopicWhereUniqueInput!): Topic
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertAdmin(create: AdminCreateInput!, update: AdminUpdateInput!, where: AdminWhereUniqueInput!): Admin!
  upsertAssignment(create: AssignmentCreateInput!, update: AssignmentUpdateInput!, where: AssignmentWhereUniqueInput!): Assignment!
  upsertAssignmentFile(create: AssignmentFileCreateInput!, update: AssignmentFileUpdateInput!, where: AssignmentFileWhereUniqueInput!): AssignmentFile!
  upsertCourse(create: CourseCreateInput!, update: CourseUpdateInput!, where: CourseWhereUniqueInput!): Course!
  upsertDepartment(create: DepartmentCreateInput!, update: DepartmentUpdateInput!, where: DepartmentWhereUniqueInput!): Department!
  upsertLesson(create: LessonCreateInput!, update: LessonUpdateInput!, where: LessonWhereUniqueInput!): Lesson!
  upsertLessonFile(create: LessonFileCreateInput!, update: LessonFileUpdateInput!, where: LessonFileWhereUniqueInput!): LessonFile!
  upsertMeeting(create: MeetingCreateInput!, update: MeetingUpdateInput!, where: MeetingWhereUniqueInput!): Meeting!
  upsertStudent(create: StudentCreateInput!, update: StudentUpdateInput!, where: StudentWhereUniqueInput!): Student!
  upsertSubmission(create: SubmissionCreateInput!, update: SubmissionUpdateInput!, where: SubmissionWhereUniqueInput!): Submission!
  upsertSubmissionFile(create: SubmissionFileCreateInput!, update: SubmissionFileUpdateInput!, where: SubmissionFileWhereUniqueInput!): SubmissionFile!
  upsertTeacher(create: TeacherCreateInput!, update: TeacherUpdateInput!, where: TeacherWhereUniqueInput!): Teacher!
  upsertTopic(create: TopicCreateInput!, update: TopicUpdateInput!, where: TopicWhereUniqueInput!): Topic!
  upsertUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  admin(where: AdminWhereUniqueInput!): Admin
  admins(cursor: AdminWhereUniqueInput, distinct: [AdminScalarFieldEnum!], orderBy: [AdminOrderByWithRelationInput!], skip: Int, take: Int, where: AdminWhereInput): [Admin!]!
  aggregateAdmin(cursor: AdminWhereUniqueInput, orderBy: [AdminOrderByWithRelationInput!], skip: Int, take: Int, where: AdminWhereInput): AggregateAdmin!
  aggregateAssignment(cursor: AssignmentWhereUniqueInput, orderBy: [AssignmentOrderByWithRelationInput!], skip: Int, take: Int, where: AssignmentWhereInput): AggregateAssignment!
  aggregateAssignmentFile(cursor: AssignmentFileWhereUniqueInput, orderBy: [AssignmentFileOrderByWithRelationInput!], skip: Int, take: Int, where: AssignmentFileWhereInput): AggregateAssignmentFile!
  aggregateCourse(cursor: CourseWhereUniqueInput, orderBy: [CourseOrderByWithRelationInput!], skip: Int, take: Int, where: CourseWhereInput): AggregateCourse!
  aggregateDepartment(cursor: DepartmentWhereUniqueInput, orderBy: [DepartmentOrderByWithRelationInput!], skip: Int, take: Int, where: DepartmentWhereInput): AggregateDepartment!
  aggregateLesson(cursor: LessonWhereUniqueInput, orderBy: [LessonOrderByWithRelationInput!], skip: Int, take: Int, where: LessonWhereInput): AggregateLesson!
  aggregateLessonFile(cursor: LessonFileWhereUniqueInput, orderBy: [LessonFileOrderByWithRelationInput!], skip: Int, take: Int, where: LessonFileWhereInput): AggregateLessonFile!
  aggregateMeeting(cursor: MeetingWhereUniqueInput, orderBy: [MeetingOrderByWithRelationInput!], skip: Int, take: Int, where: MeetingWhereInput): AggregateMeeting!
  aggregateStudent(cursor: StudentWhereUniqueInput, orderBy: [StudentOrderByWithRelationInput!], skip: Int, take: Int, where: StudentWhereInput): AggregateStudent!
  aggregateSubmission(cursor: SubmissionWhereUniqueInput, orderBy: [SubmissionOrderByWithRelationInput!], skip: Int, take: Int, where: SubmissionWhereInput): AggregateSubmission!
  aggregateSubmissionFile(cursor: SubmissionFileWhereUniqueInput, orderBy: [SubmissionFileOrderByWithRelationInput!], skip: Int, take: Int, where: SubmissionFileWhereInput): AggregateSubmissionFile!
  aggregateTeacher(cursor: TeacherWhereUniqueInput, orderBy: [TeacherOrderByWithRelationInput!], skip: Int, take: Int, where: TeacherWhereInput): AggregateTeacher!
  aggregateTopic(cursor: TopicWhereUniqueInput, orderBy: [TopicOrderByWithRelationInput!], skip: Int, take: Int, where: TopicWhereInput): AggregateTopic!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  assignment(where: AssignmentWhereUniqueInput!): Assignment
  assignmentFile(where: AssignmentFileWhereUniqueInput!): AssignmentFile
  assignmentFiles(cursor: AssignmentFileWhereUniqueInput, distinct: [AssignmentFileScalarFieldEnum!], orderBy: [AssignmentFileOrderByWithRelationInput!], skip: Int, take: Int, where: AssignmentFileWhereInput): [AssignmentFile!]!
  assignments(cursor: AssignmentWhereUniqueInput, distinct: [AssignmentScalarFieldEnum!], orderBy: [AssignmentOrderByWithRelationInput!], skip: Int, take: Int, where: AssignmentWhereInput): [Assignment!]!
  course(where: CourseWhereUniqueInput!): Course
  courses(cursor: CourseWhereUniqueInput, distinct: [CourseScalarFieldEnum!], orderBy: [CourseOrderByWithRelationInput!], skip: Int, take: Int, where: CourseWhereInput): [Course!]!
  department(where: DepartmentWhereUniqueInput!): Department
  departments(cursor: DepartmentWhereUniqueInput, distinct: [DepartmentScalarFieldEnum!], orderBy: [DepartmentOrderByWithRelationInput!], skip: Int, take: Int, where: DepartmentWhereInput): [Department!]!
  findFirstAdmin(cursor: AdminWhereUniqueInput, distinct: [AdminScalarFieldEnum!], orderBy: [AdminOrderByWithRelationInput!], skip: Int, take: Int, where: AdminWhereInput): Admin
  findFirstAssignment(cursor: AssignmentWhereUniqueInput, distinct: [AssignmentScalarFieldEnum!], orderBy: [AssignmentOrderByWithRelationInput!], skip: Int, take: Int, where: AssignmentWhereInput): Assignment
  findFirstAssignmentFile(cursor: AssignmentFileWhereUniqueInput, distinct: [AssignmentFileScalarFieldEnum!], orderBy: [AssignmentFileOrderByWithRelationInput!], skip: Int, take: Int, where: AssignmentFileWhereInput): AssignmentFile
  findFirstCourse(cursor: CourseWhereUniqueInput, distinct: [CourseScalarFieldEnum!], orderBy: [CourseOrderByWithRelationInput!], skip: Int, take: Int, where: CourseWhereInput): Course
  findFirstDepartment(cursor: DepartmentWhereUniqueInput, distinct: [DepartmentScalarFieldEnum!], orderBy: [DepartmentOrderByWithRelationInput!], skip: Int, take: Int, where: DepartmentWhereInput): Department
  findFirstLesson(cursor: LessonWhereUniqueInput, distinct: [LessonScalarFieldEnum!], orderBy: [LessonOrderByWithRelationInput!], skip: Int, take: Int, where: LessonWhereInput): Lesson
  findFirstLessonFile(cursor: LessonFileWhereUniqueInput, distinct: [LessonFileScalarFieldEnum!], orderBy: [LessonFileOrderByWithRelationInput!], skip: Int, take: Int, where: LessonFileWhereInput): LessonFile
  findFirstMeeting(cursor: MeetingWhereUniqueInput, distinct: [MeetingScalarFieldEnum!], orderBy: [MeetingOrderByWithRelationInput!], skip: Int, take: Int, where: MeetingWhereInput): Meeting
  findFirstStudent(cursor: StudentWhereUniqueInput, distinct: [StudentScalarFieldEnum!], orderBy: [StudentOrderByWithRelationInput!], skip: Int, take: Int, where: StudentWhereInput): Student
  findFirstSubmission(cursor: SubmissionWhereUniqueInput, distinct: [SubmissionScalarFieldEnum!], orderBy: [SubmissionOrderByWithRelationInput!], skip: Int, take: Int, where: SubmissionWhereInput): Submission
  findFirstSubmissionFile(cursor: SubmissionFileWhereUniqueInput, distinct: [SubmissionFileScalarFieldEnum!], orderBy: [SubmissionFileOrderByWithRelationInput!], skip: Int, take: Int, where: SubmissionFileWhereInput): SubmissionFile
  findFirstTeacher(cursor: TeacherWhereUniqueInput, distinct: [TeacherScalarFieldEnum!], orderBy: [TeacherOrderByWithRelationInput!], skip: Int, take: Int, where: TeacherWhereInput): Teacher
  findFirstTopic(cursor: TopicWhereUniqueInput, distinct: [TopicScalarFieldEnum!], orderBy: [TopicOrderByWithRelationInput!], skip: Int, take: Int, where: TopicWhereInput): Topic
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  groupByAdmin(by: [AdminScalarFieldEnum!]!, having: AdminScalarWhereWithAggregatesInput, orderBy: [AdminOrderByWithAggregationInput!], skip: Int, take: Int, where: AdminWhereInput): [AdminGroupBy!]!
  groupByAssignment(by: [AssignmentScalarFieldEnum!]!, having: AssignmentScalarWhereWithAggregatesInput, orderBy: [AssignmentOrderByWithAggregationInput!], skip: Int, take: Int, where: AssignmentWhereInput): [AssignmentGroupBy!]!
  groupByAssignmentFile(by: [AssignmentFileScalarFieldEnum!]!, having: AssignmentFileScalarWhereWithAggregatesInput, orderBy: [AssignmentFileOrderByWithAggregationInput!], skip: Int, take: Int, where: AssignmentFileWhereInput): [AssignmentFileGroupBy!]!
  groupByCourse(by: [CourseScalarFieldEnum!]!, having: CourseScalarWhereWithAggregatesInput, orderBy: [CourseOrderByWithAggregationInput!], skip: Int, take: Int, where: CourseWhereInput): [CourseGroupBy!]!
  groupByDepartment(by: [DepartmentScalarFieldEnum!]!, having: DepartmentScalarWhereWithAggregatesInput, orderBy: [DepartmentOrderByWithAggregationInput!], skip: Int, take: Int, where: DepartmentWhereInput): [DepartmentGroupBy!]!
  groupByLesson(by: [LessonScalarFieldEnum!]!, having: LessonScalarWhereWithAggregatesInput, orderBy: [LessonOrderByWithAggregationInput!], skip: Int, take: Int, where: LessonWhereInput): [LessonGroupBy!]!
  groupByLessonFile(by: [LessonFileScalarFieldEnum!]!, having: LessonFileScalarWhereWithAggregatesInput, orderBy: [LessonFileOrderByWithAggregationInput!], skip: Int, take: Int, where: LessonFileWhereInput): [LessonFileGroupBy!]!
  groupByMeeting(by: [MeetingScalarFieldEnum!]!, having: MeetingScalarWhereWithAggregatesInput, orderBy: [MeetingOrderByWithAggregationInput!], skip: Int, take: Int, where: MeetingWhereInput): [MeetingGroupBy!]!
  groupByStudent(by: [StudentScalarFieldEnum!]!, having: StudentScalarWhereWithAggregatesInput, orderBy: [StudentOrderByWithAggregationInput!], skip: Int, take: Int, where: StudentWhereInput): [StudentGroupBy!]!
  groupBySubmission(by: [SubmissionScalarFieldEnum!]!, having: SubmissionScalarWhereWithAggregatesInput, orderBy: [SubmissionOrderByWithAggregationInput!], skip: Int, take: Int, where: SubmissionWhereInput): [SubmissionGroupBy!]!
  groupBySubmissionFile(by: [SubmissionFileScalarFieldEnum!]!, having: SubmissionFileScalarWhereWithAggregatesInput, orderBy: [SubmissionFileOrderByWithAggregationInput!], skip: Int, take: Int, where: SubmissionFileWhereInput): [SubmissionFileGroupBy!]!
  groupByTeacher(by: [TeacherScalarFieldEnum!]!, having: TeacherScalarWhereWithAggregatesInput, orderBy: [TeacherOrderByWithAggregationInput!], skip: Int, take: Int, where: TeacherWhereInput): [TeacherGroupBy!]!
  groupByTopic(by: [TopicScalarFieldEnum!]!, having: TopicScalarWhereWithAggregatesInput, orderBy: [TopicOrderByWithAggregationInput!], skip: Int, take: Int, where: TopicWhereInput): [TopicGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  lesson(where: LessonWhereUniqueInput!): Lesson
  lessonFile(where: LessonFileWhereUniqueInput!): LessonFile
  lessonFiles(cursor: LessonFileWhereUniqueInput, distinct: [LessonFileScalarFieldEnum!], orderBy: [LessonFileOrderByWithRelationInput!], skip: Int, take: Int, where: LessonFileWhereInput): [LessonFile!]!
  lessons(cursor: LessonWhereUniqueInput, distinct: [LessonScalarFieldEnum!], orderBy: [LessonOrderByWithRelationInput!], skip: Int, take: Int, where: LessonWhereInput): [Lesson!]!
  meeting(where: MeetingWhereUniqueInput!): Meeting
  meetings(cursor: MeetingWhereUniqueInput, distinct: [MeetingScalarFieldEnum!], orderBy: [MeetingOrderByWithRelationInput!], skip: Int, take: Int, where: MeetingWhereInput): [Meeting!]!
  student(where: StudentWhereUniqueInput!): Student
  students(cursor: StudentWhereUniqueInput, distinct: [StudentScalarFieldEnum!], orderBy: [StudentOrderByWithRelationInput!], skip: Int, take: Int, where: StudentWhereInput): [Student!]!
  submission(where: SubmissionWhereUniqueInput!): Submission
  submissionFile(where: SubmissionFileWhereUniqueInput!): SubmissionFile
  submissionFiles(cursor: SubmissionFileWhereUniqueInput, distinct: [SubmissionFileScalarFieldEnum!], orderBy: [SubmissionFileOrderByWithRelationInput!], skip: Int, take: Int, where: SubmissionFileWhereInput): [SubmissionFile!]!
  submissions(cursor: SubmissionWhereUniqueInput, distinct: [SubmissionScalarFieldEnum!], orderBy: [SubmissionOrderByWithRelationInput!], skip: Int, take: Int, where: SubmissionWhereInput): [Submission!]!
  teacher(where: TeacherWhereUniqueInput!): Teacher
  teachers(cursor: TeacherWhereUniqueInput, distinct: [TeacherScalarFieldEnum!], orderBy: [TeacherOrderByWithRelationInput!], skip: Int, take: Int, where: TeacherWhereInput): [Teacher!]!
  topic(where: TopicWhereUniqueInput!): Topic
  topics(cursor: TopicWhereUniqueInput, distinct: [TopicScalarFieldEnum!], orderBy: [TopicOrderByWithRelationInput!], skip: Int, take: Int, where: TopicWhereInput): [Topic!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Student {
  _count: StudentCount
  firstName: String!
  grade: Int!
  id: Int!
  lastName: String!
  submissions(cursor: SubmissionWhereUniqueInput, distinct: [SubmissionScalarFieldEnum!], orderBy: [SubmissionOrderByWithRelationInput!], skip: Int, take: Int, where: SubmissionWhereInput): [Submission!]!
  topic: Topic
  topicId: Int
  user: User!
  userId: Int!
}

type StudentAvgAggregate {
  grade: Float
  id: Float
  topicId: Float
  userId: Float
}

input StudentAvgOrderByAggregateInput {
  grade: SortOrder
  id: SortOrder
  topicId: SortOrder
  userId: SortOrder
}

type StudentCount {
  submissions: Int!
}

type StudentCountAggregate {
  _all: Int!
  firstName: Int!
  grade: Int!
  id: Int!
  lastName: Int!
  topicId: Int!
  userId: Int!
}

input StudentCountOrderByAggregateInput {
  firstName: SortOrder
  grade: SortOrder
  id: SortOrder
  lastName: SortOrder
  topicId: SortOrder
  userId: SortOrder
}

input StudentCreateInput {
  firstName: String!
  grade: Int!
  lastName: String!
  submissions: SubmissionCreateNestedManyWithoutStudentInput
  topic: TopicCreateNestedOneWithoutStudentsInput
  user: UserCreateNestedOneWithoutStudentInput!
}

input StudentCreateNestedManyWithoutTopicInput {
  connect: [StudentWhereUniqueInput!]
  connectOrCreate: [StudentCreateOrConnectWithoutTopicInput!]
  create: [StudentCreateWithoutTopicInput!]
}

input StudentCreateNestedOneWithoutSubmissionsInput {
  connect: StudentWhereUniqueInput
  connectOrCreate: StudentCreateOrConnectWithoutSubmissionsInput
  create: StudentCreateWithoutSubmissionsInput
}

input StudentCreateNestedOneWithoutUserInput {
  connect: StudentWhereUniqueInput
  connectOrCreate: StudentCreateOrConnectWithoutUserInput
  create: StudentCreateWithoutUserInput
}

input StudentCreateOrConnectWithoutSubmissionsInput {
  create: StudentCreateWithoutSubmissionsInput!
  where: StudentWhereUniqueInput!
}

input StudentCreateOrConnectWithoutTopicInput {
  create: StudentCreateWithoutTopicInput!
  where: StudentWhereUniqueInput!
}

input StudentCreateOrConnectWithoutUserInput {
  create: StudentCreateWithoutUserInput!
  where: StudentWhereUniqueInput!
}

input StudentCreateWithoutSubmissionsInput {
  firstName: String!
  grade: Int!
  lastName: String!
  topic: TopicCreateNestedOneWithoutStudentsInput
  user: UserCreateNestedOneWithoutStudentInput!
}

input StudentCreateWithoutTopicInput {
  firstName: String!
  grade: Int!
  lastName: String!
  submissions: SubmissionCreateNestedManyWithoutStudentInput
  user: UserCreateNestedOneWithoutStudentInput!
}

input StudentCreateWithoutUserInput {
  firstName: String!
  grade: Int!
  lastName: String!
  submissions: SubmissionCreateNestedManyWithoutStudentInput
  topic: TopicCreateNestedOneWithoutStudentsInput
}

type StudentGroupBy {
  _avg: StudentAvgAggregate
  _count: StudentCountAggregate
  _max: StudentMaxAggregate
  _min: StudentMinAggregate
  _sum: StudentSumAggregate
  firstName: String!
  grade: Int!
  id: Int!
  lastName: String!
  topicId: Int
  userId: Int!
}

input StudentListRelationFilter {
  every: StudentWhereInput
  none: StudentWhereInput
  some: StudentWhereInput
}

type StudentMaxAggregate {
  firstName: String
  grade: Int
  id: Int
  lastName: String
  topicId: Int
  userId: Int
}

input StudentMaxOrderByAggregateInput {
  firstName: SortOrder
  grade: SortOrder
  id: SortOrder
  lastName: SortOrder
  topicId: SortOrder
  userId: SortOrder
}

type StudentMinAggregate {
  firstName: String
  grade: Int
  id: Int
  lastName: String
  topicId: Int
  userId: Int
}

input StudentMinOrderByAggregateInput {
  firstName: SortOrder
  grade: SortOrder
  id: SortOrder
  lastName: SortOrder
  topicId: SortOrder
  userId: SortOrder
}

input StudentOrderByRelationAggregateInput {
  _count: SortOrder
}

input StudentOrderByWithAggregationInput {
  _avg: StudentAvgOrderByAggregateInput
  _count: StudentCountOrderByAggregateInput
  _max: StudentMaxOrderByAggregateInput
  _min: StudentMinOrderByAggregateInput
  _sum: StudentSumOrderByAggregateInput
  firstName: SortOrder
  grade: SortOrder
  id: SortOrder
  lastName: SortOrder
  topicId: SortOrder
  userId: SortOrder
}

input StudentOrderByWithRelationInput {
  firstName: SortOrder
  grade: SortOrder
  id: SortOrder
  lastName: SortOrder
  submissions: SubmissionOrderByRelationAggregateInput
  topic: TopicOrderByWithRelationInput
  topicId: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input StudentRelationFilter {
  is: StudentWhereInput
  isNot: StudentWhereInput
}

enum StudentScalarFieldEnum {
  firstName
  grade
  id
  lastName
  topicId
  userId
}

input StudentScalarWhereInput {
  AND: [StudentScalarWhereInput!]
  NOT: [StudentScalarWhereInput!]
  OR: [StudentScalarWhereInput!]
  firstName: StringFilter
  grade: IntFilter
  id: IntFilter
  lastName: StringFilter
  topicId: IntNullableFilter
  userId: IntFilter
}

input StudentScalarWhereWithAggregatesInput {
  AND: [StudentScalarWhereWithAggregatesInput!]
  NOT: [StudentScalarWhereWithAggregatesInput!]
  OR: [StudentScalarWhereWithAggregatesInput!]
  firstName: StringWithAggregatesFilter
  grade: IntWithAggregatesFilter
  id: IntWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  topicId: IntNullableWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type StudentSumAggregate {
  grade: Int
  id: Int
  topicId: Int
  userId: Int
}

input StudentSumOrderByAggregateInput {
  grade: SortOrder
  id: SortOrder
  topicId: SortOrder
  userId: SortOrder
}

input StudentUpdateInput {
  firstName: StringFieldUpdateOperationsInput
  grade: IntFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  submissions: SubmissionUpdateManyWithoutStudentInput
  topic: TopicUpdateOneWithoutStudentsInput
  user: UserUpdateOneRequiredWithoutStudentInput
}

input StudentUpdateManyMutationInput {
  firstName: StringFieldUpdateOperationsInput
  grade: IntFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
}

input StudentUpdateManyWithWhereWithoutTopicInput {
  data: StudentUpdateManyMutationInput!
  where: StudentScalarWhereInput!
}

input StudentUpdateManyWithoutTopicInput {
  connect: [StudentWhereUniqueInput!]
  connectOrCreate: [StudentCreateOrConnectWithoutTopicInput!]
  create: [StudentCreateWithoutTopicInput!]
  delete: [StudentWhereUniqueInput!]
  deleteMany: [StudentScalarWhereInput!]
  disconnect: [StudentWhereUniqueInput!]
  set: [StudentWhereUniqueInput!]
  update: [StudentUpdateWithWhereUniqueWithoutTopicInput!]
  updateMany: [StudentUpdateManyWithWhereWithoutTopicInput!]
  upsert: [StudentUpsertWithWhereUniqueWithoutTopicInput!]
}

input StudentUpdateOneWithoutSubmissionsInput {
  connect: StudentWhereUniqueInput
  connectOrCreate: StudentCreateOrConnectWithoutSubmissionsInput
  create: StudentCreateWithoutSubmissionsInput
  delete: Boolean
  disconnect: Boolean
  update: StudentUpdateWithoutSubmissionsInput
  upsert: StudentUpsertWithoutSubmissionsInput
}

input StudentUpdateOneWithoutUserInput {
  connect: StudentWhereUniqueInput
  connectOrCreate: StudentCreateOrConnectWithoutUserInput
  create: StudentCreateWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  update: StudentUpdateWithoutUserInput
  upsert: StudentUpsertWithoutUserInput
}

input StudentUpdateWithWhereUniqueWithoutTopicInput {
  data: StudentUpdateWithoutTopicInput!
  where: StudentWhereUniqueInput!
}

input StudentUpdateWithoutSubmissionsInput {
  firstName: StringFieldUpdateOperationsInput
  grade: IntFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  topic: TopicUpdateOneWithoutStudentsInput
  user: UserUpdateOneRequiredWithoutStudentInput
}

input StudentUpdateWithoutTopicInput {
  firstName: StringFieldUpdateOperationsInput
  grade: IntFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  submissions: SubmissionUpdateManyWithoutStudentInput
  user: UserUpdateOneRequiredWithoutStudentInput
}

input StudentUpdateWithoutUserInput {
  firstName: StringFieldUpdateOperationsInput
  grade: IntFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  submissions: SubmissionUpdateManyWithoutStudentInput
  topic: TopicUpdateOneWithoutStudentsInput
}

input StudentUpsertWithWhereUniqueWithoutTopicInput {
  create: StudentCreateWithoutTopicInput!
  update: StudentUpdateWithoutTopicInput!
  where: StudentWhereUniqueInput!
}

input StudentUpsertWithoutSubmissionsInput {
  create: StudentCreateWithoutSubmissionsInput!
  update: StudentUpdateWithoutSubmissionsInput!
}

input StudentUpsertWithoutUserInput {
  create: StudentCreateWithoutUserInput!
  update: StudentUpdateWithoutUserInput!
}

input StudentWhereInput {
  AND: [StudentWhereInput!]
  NOT: [StudentWhereInput!]
  OR: [StudentWhereInput!]
  firstName: StringFilter
  grade: IntFilter
  id: IntFilter
  lastName: StringFilter
  submissions: SubmissionListRelationFilter
  topic: TopicRelationFilter
  topicId: IntNullableFilter
  user: UserRelationFilter
  userId: IntFilter
}

input StudentWhereUniqueInput {
  id: Int
  userId: Int
}

type Submission {
  _count: SubmissionCount
  assignment: Assignment
  assignmentId: Int
  content: String!
  createdAt: DateTime!
  id: Int!
  student: Student
  studentId: Int
  submissionFiles(cursor: SubmissionFileWhereUniqueInput, distinct: [SubmissionFileScalarFieldEnum!], orderBy: [SubmissionFileOrderByWithRelationInput!], skip: Int, take: Int, where: SubmissionFileWhereInput): [SubmissionFile!]!
  updatedAt: DateTime!
}

type SubmissionAvgAggregate {
  assignmentId: Float
  id: Float
  studentId: Float
}

input SubmissionAvgOrderByAggregateInput {
  assignmentId: SortOrder
  id: SortOrder
  studentId: SortOrder
}

type SubmissionCount {
  submissionFiles: Int!
}

type SubmissionCountAggregate {
  _all: Int!
  assignmentId: Int!
  content: Int!
  createdAt: Int!
  id: Int!
  studentId: Int!
  updatedAt: Int!
}

input SubmissionCountOrderByAggregateInput {
  assignmentId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  studentId: SortOrder
  updatedAt: SortOrder
}

input SubmissionCreateInput {
  assignment: AssignmentCreateNestedOneWithoutSubmissionsInput
  content: String!
  createdAt: DateTime
  student: StudentCreateNestedOneWithoutSubmissionsInput
  submissionFiles: SubmissionFileCreateNestedManyWithoutSubmissionInput
  updatedAt: DateTime
}

input SubmissionCreateNestedManyWithoutAssignmentInput {
  connect: [SubmissionWhereUniqueInput!]
  connectOrCreate: [SubmissionCreateOrConnectWithoutAssignmentInput!]
  create: [SubmissionCreateWithoutAssignmentInput!]
}

input SubmissionCreateNestedManyWithoutStudentInput {
  connect: [SubmissionWhereUniqueInput!]
  connectOrCreate: [SubmissionCreateOrConnectWithoutStudentInput!]
  create: [SubmissionCreateWithoutStudentInput!]
}

input SubmissionCreateNestedOneWithoutSubmissionFilesInput {
  connect: SubmissionWhereUniqueInput
  connectOrCreate: SubmissionCreateOrConnectWithoutSubmissionFilesInput
  create: SubmissionCreateWithoutSubmissionFilesInput
}

input SubmissionCreateOrConnectWithoutAssignmentInput {
  create: SubmissionCreateWithoutAssignmentInput!
  where: SubmissionWhereUniqueInput!
}

input SubmissionCreateOrConnectWithoutStudentInput {
  create: SubmissionCreateWithoutStudentInput!
  where: SubmissionWhereUniqueInput!
}

input SubmissionCreateOrConnectWithoutSubmissionFilesInput {
  create: SubmissionCreateWithoutSubmissionFilesInput!
  where: SubmissionWhereUniqueInput!
}

input SubmissionCreateWithoutAssignmentInput {
  content: String!
  createdAt: DateTime
  student: StudentCreateNestedOneWithoutSubmissionsInput
  submissionFiles: SubmissionFileCreateNestedManyWithoutSubmissionInput
  updatedAt: DateTime
}

input SubmissionCreateWithoutStudentInput {
  assignment: AssignmentCreateNestedOneWithoutSubmissionsInput
  content: String!
  createdAt: DateTime
  submissionFiles: SubmissionFileCreateNestedManyWithoutSubmissionInput
  updatedAt: DateTime
}

input SubmissionCreateWithoutSubmissionFilesInput {
  assignment: AssignmentCreateNestedOneWithoutSubmissionsInput
  content: String!
  createdAt: DateTime
  student: StudentCreateNestedOneWithoutSubmissionsInput
  updatedAt: DateTime
}

type SubmissionFile {
  createdAt: DateTime!
  id: Int!
  link: String!
  name: String!
  submission: Submission
  submissionId: Int
  type: String!
  updatedAt: DateTime!
}

type SubmissionFileAvgAggregate {
  id: Float
  submissionId: Float
}

input SubmissionFileAvgOrderByAggregateInput {
  id: SortOrder
  submissionId: SortOrder
}

type SubmissionFileCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  link: Int!
  name: Int!
  submissionId: Int!
  type: Int!
  updatedAt: Int!
}

input SubmissionFileCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  link: SortOrder
  name: SortOrder
  submissionId: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

input SubmissionFileCreateInput {
  createdAt: DateTime
  link: String!
  name: String!
  submission: SubmissionCreateNestedOneWithoutSubmissionFilesInput
  type: String!
  updatedAt: DateTime
}

input SubmissionFileCreateNestedManyWithoutSubmissionInput {
  connect: [SubmissionFileWhereUniqueInput!]
  connectOrCreate: [SubmissionFileCreateOrConnectWithoutSubmissionInput!]
  create: [SubmissionFileCreateWithoutSubmissionInput!]
}

input SubmissionFileCreateOrConnectWithoutSubmissionInput {
  create: SubmissionFileCreateWithoutSubmissionInput!
  where: SubmissionFileWhereUniqueInput!
}

input SubmissionFileCreateWithoutSubmissionInput {
  createdAt: DateTime
  link: String!
  name: String!
  type: String!
  updatedAt: DateTime
}

type SubmissionFileGroupBy {
  _avg: SubmissionFileAvgAggregate
  _count: SubmissionFileCountAggregate
  _max: SubmissionFileMaxAggregate
  _min: SubmissionFileMinAggregate
  _sum: SubmissionFileSumAggregate
  createdAt: DateTime!
  id: Int!
  link: String!
  name: String!
  submissionId: Int
  type: String!
  updatedAt: DateTime!
}

input SubmissionFileListRelationFilter {
  every: SubmissionFileWhereInput
  none: SubmissionFileWhereInput
  some: SubmissionFileWhereInput
}

type SubmissionFileMaxAggregate {
  createdAt: DateTime
  id: Int
  link: String
  name: String
  submissionId: Int
  type: String
  updatedAt: DateTime
}

input SubmissionFileMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  link: SortOrder
  name: SortOrder
  submissionId: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

type SubmissionFileMinAggregate {
  createdAt: DateTime
  id: Int
  link: String
  name: String
  submissionId: Int
  type: String
  updatedAt: DateTime
}

input SubmissionFileMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  link: SortOrder
  name: SortOrder
  submissionId: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

input SubmissionFileOrderByRelationAggregateInput {
  _count: SortOrder
}

input SubmissionFileOrderByWithAggregationInput {
  _avg: SubmissionFileAvgOrderByAggregateInput
  _count: SubmissionFileCountOrderByAggregateInput
  _max: SubmissionFileMaxOrderByAggregateInput
  _min: SubmissionFileMinOrderByAggregateInput
  _sum: SubmissionFileSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  link: SortOrder
  name: SortOrder
  submissionId: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

input SubmissionFileOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  link: SortOrder
  name: SortOrder
  submission: SubmissionOrderByWithRelationInput
  submissionId: SortOrder
  type: SortOrder
  updatedAt: SortOrder
}

enum SubmissionFileScalarFieldEnum {
  createdAt
  id
  link
  name
  submissionId
  type
  updatedAt
}

input SubmissionFileScalarWhereInput {
  AND: [SubmissionFileScalarWhereInput!]
  NOT: [SubmissionFileScalarWhereInput!]
  OR: [SubmissionFileScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  link: StringFilter
  name: StringFilter
  submissionId: IntNullableFilter
  type: StringFilter
  updatedAt: DateTimeFilter
}

input SubmissionFileScalarWhereWithAggregatesInput {
  AND: [SubmissionFileScalarWhereWithAggregatesInput!]
  NOT: [SubmissionFileScalarWhereWithAggregatesInput!]
  OR: [SubmissionFileScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  link: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  submissionId: IntNullableWithAggregatesFilter
  type: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type SubmissionFileSumAggregate {
  id: Int
  submissionId: Int
}

input SubmissionFileSumOrderByAggregateInput {
  id: SortOrder
  submissionId: SortOrder
}

input SubmissionFileUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  link: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  submission: SubmissionUpdateOneWithoutSubmissionFilesInput
  type: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SubmissionFileUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  link: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SubmissionFileUpdateManyWithWhereWithoutSubmissionInput {
  data: SubmissionFileUpdateManyMutationInput!
  where: SubmissionFileScalarWhereInput!
}

input SubmissionFileUpdateManyWithoutSubmissionInput {
  connect: [SubmissionFileWhereUniqueInput!]
  connectOrCreate: [SubmissionFileCreateOrConnectWithoutSubmissionInput!]
  create: [SubmissionFileCreateWithoutSubmissionInput!]
  delete: [SubmissionFileWhereUniqueInput!]
  deleteMany: [SubmissionFileScalarWhereInput!]
  disconnect: [SubmissionFileWhereUniqueInput!]
  set: [SubmissionFileWhereUniqueInput!]
  update: [SubmissionFileUpdateWithWhereUniqueWithoutSubmissionInput!]
  updateMany: [SubmissionFileUpdateManyWithWhereWithoutSubmissionInput!]
  upsert: [SubmissionFileUpsertWithWhereUniqueWithoutSubmissionInput!]
}

input SubmissionFileUpdateWithWhereUniqueWithoutSubmissionInput {
  data: SubmissionFileUpdateWithoutSubmissionInput!
  where: SubmissionFileWhereUniqueInput!
}

input SubmissionFileUpdateWithoutSubmissionInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  link: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SubmissionFileUpsertWithWhereUniqueWithoutSubmissionInput {
  create: SubmissionFileCreateWithoutSubmissionInput!
  update: SubmissionFileUpdateWithoutSubmissionInput!
  where: SubmissionFileWhereUniqueInput!
}

input SubmissionFileWhereInput {
  AND: [SubmissionFileWhereInput!]
  NOT: [SubmissionFileWhereInput!]
  OR: [SubmissionFileWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  link: StringFilter
  name: StringFilter
  submission: SubmissionRelationFilter
  submissionId: IntNullableFilter
  type: StringFilter
  updatedAt: DateTimeFilter
}

input SubmissionFileWhereUniqueInput {
  id: Int
}

type SubmissionGroupBy {
  _avg: SubmissionAvgAggregate
  _count: SubmissionCountAggregate
  _max: SubmissionMaxAggregate
  _min: SubmissionMinAggregate
  _sum: SubmissionSumAggregate
  assignmentId: Int
  content: String!
  createdAt: DateTime!
  id: Int!
  studentId: Int
  updatedAt: DateTime!
}

input SubmissionListRelationFilter {
  every: SubmissionWhereInput
  none: SubmissionWhereInput
  some: SubmissionWhereInput
}

type SubmissionMaxAggregate {
  assignmentId: Int
  content: String
  createdAt: DateTime
  id: Int
  studentId: Int
  updatedAt: DateTime
}

input SubmissionMaxOrderByAggregateInput {
  assignmentId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  studentId: SortOrder
  updatedAt: SortOrder
}

type SubmissionMinAggregate {
  assignmentId: Int
  content: String
  createdAt: DateTime
  id: Int
  studentId: Int
  updatedAt: DateTime
}

input SubmissionMinOrderByAggregateInput {
  assignmentId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  studentId: SortOrder
  updatedAt: SortOrder
}

input SubmissionOrderByRelationAggregateInput {
  _count: SortOrder
}

input SubmissionOrderByWithAggregationInput {
  _avg: SubmissionAvgOrderByAggregateInput
  _count: SubmissionCountOrderByAggregateInput
  _max: SubmissionMaxOrderByAggregateInput
  _min: SubmissionMinOrderByAggregateInput
  _sum: SubmissionSumOrderByAggregateInput
  assignmentId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  studentId: SortOrder
  updatedAt: SortOrder
}

input SubmissionOrderByWithRelationInput {
  assignment: AssignmentOrderByWithRelationInput
  assignmentId: SortOrder
  content: SortOrder
  createdAt: SortOrder
  id: SortOrder
  student: StudentOrderByWithRelationInput
  studentId: SortOrder
  submissionFiles: SubmissionFileOrderByRelationAggregateInput
  updatedAt: SortOrder
}

input SubmissionRelationFilter {
  is: SubmissionWhereInput
  isNot: SubmissionWhereInput
}

enum SubmissionScalarFieldEnum {
  assignmentId
  content
  createdAt
  id
  studentId
  updatedAt
}

input SubmissionScalarWhereInput {
  AND: [SubmissionScalarWhereInput!]
  NOT: [SubmissionScalarWhereInput!]
  OR: [SubmissionScalarWhereInput!]
  assignmentId: IntNullableFilter
  content: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  studentId: IntNullableFilter
  updatedAt: DateTimeFilter
}

input SubmissionScalarWhereWithAggregatesInput {
  AND: [SubmissionScalarWhereWithAggregatesInput!]
  NOT: [SubmissionScalarWhereWithAggregatesInput!]
  OR: [SubmissionScalarWhereWithAggregatesInput!]
  assignmentId: IntNullableWithAggregatesFilter
  content: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  studentId: IntNullableWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type SubmissionSumAggregate {
  assignmentId: Int
  id: Int
  studentId: Int
}

input SubmissionSumOrderByAggregateInput {
  assignmentId: SortOrder
  id: SortOrder
  studentId: SortOrder
}

input SubmissionUpdateInput {
  assignment: AssignmentUpdateOneWithoutSubmissionsInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  student: StudentUpdateOneWithoutSubmissionsInput
  submissionFiles: SubmissionFileUpdateManyWithoutSubmissionInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SubmissionUpdateManyMutationInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SubmissionUpdateManyWithWhereWithoutAssignmentInput {
  data: SubmissionUpdateManyMutationInput!
  where: SubmissionScalarWhereInput!
}

input SubmissionUpdateManyWithWhereWithoutStudentInput {
  data: SubmissionUpdateManyMutationInput!
  where: SubmissionScalarWhereInput!
}

input SubmissionUpdateManyWithoutAssignmentInput {
  connect: [SubmissionWhereUniqueInput!]
  connectOrCreate: [SubmissionCreateOrConnectWithoutAssignmentInput!]
  create: [SubmissionCreateWithoutAssignmentInput!]
  delete: [SubmissionWhereUniqueInput!]
  deleteMany: [SubmissionScalarWhereInput!]
  disconnect: [SubmissionWhereUniqueInput!]
  set: [SubmissionWhereUniqueInput!]
  update: [SubmissionUpdateWithWhereUniqueWithoutAssignmentInput!]
  updateMany: [SubmissionUpdateManyWithWhereWithoutAssignmentInput!]
  upsert: [SubmissionUpsertWithWhereUniqueWithoutAssignmentInput!]
}

input SubmissionUpdateManyWithoutStudentInput {
  connect: [SubmissionWhereUniqueInput!]
  connectOrCreate: [SubmissionCreateOrConnectWithoutStudentInput!]
  create: [SubmissionCreateWithoutStudentInput!]
  delete: [SubmissionWhereUniqueInput!]
  deleteMany: [SubmissionScalarWhereInput!]
  disconnect: [SubmissionWhereUniqueInput!]
  set: [SubmissionWhereUniqueInput!]
  update: [SubmissionUpdateWithWhereUniqueWithoutStudentInput!]
  updateMany: [SubmissionUpdateManyWithWhereWithoutStudentInput!]
  upsert: [SubmissionUpsertWithWhereUniqueWithoutStudentInput!]
}

input SubmissionUpdateOneWithoutSubmissionFilesInput {
  connect: SubmissionWhereUniqueInput
  connectOrCreate: SubmissionCreateOrConnectWithoutSubmissionFilesInput
  create: SubmissionCreateWithoutSubmissionFilesInput
  delete: Boolean
  disconnect: Boolean
  update: SubmissionUpdateWithoutSubmissionFilesInput
  upsert: SubmissionUpsertWithoutSubmissionFilesInput
}

input SubmissionUpdateWithWhereUniqueWithoutAssignmentInput {
  data: SubmissionUpdateWithoutAssignmentInput!
  where: SubmissionWhereUniqueInput!
}

input SubmissionUpdateWithWhereUniqueWithoutStudentInput {
  data: SubmissionUpdateWithoutStudentInput!
  where: SubmissionWhereUniqueInput!
}

input SubmissionUpdateWithoutAssignmentInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  student: StudentUpdateOneWithoutSubmissionsInput
  submissionFiles: SubmissionFileUpdateManyWithoutSubmissionInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SubmissionUpdateWithoutStudentInput {
  assignment: AssignmentUpdateOneWithoutSubmissionsInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  submissionFiles: SubmissionFileUpdateManyWithoutSubmissionInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SubmissionUpdateWithoutSubmissionFilesInput {
  assignment: AssignmentUpdateOneWithoutSubmissionsInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  student: StudentUpdateOneWithoutSubmissionsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SubmissionUpsertWithWhereUniqueWithoutAssignmentInput {
  create: SubmissionCreateWithoutAssignmentInput!
  update: SubmissionUpdateWithoutAssignmentInput!
  where: SubmissionWhereUniqueInput!
}

input SubmissionUpsertWithWhereUniqueWithoutStudentInput {
  create: SubmissionCreateWithoutStudentInput!
  update: SubmissionUpdateWithoutStudentInput!
  where: SubmissionWhereUniqueInput!
}

input SubmissionUpsertWithoutSubmissionFilesInput {
  create: SubmissionCreateWithoutSubmissionFilesInput!
  update: SubmissionUpdateWithoutSubmissionFilesInput!
}

input SubmissionWhereInput {
  AND: [SubmissionWhereInput!]
  NOT: [SubmissionWhereInput!]
  OR: [SubmissionWhereInput!]
  assignment: AssignmentRelationFilter
  assignmentId: IntNullableFilter
  content: StringFilter
  createdAt: DateTimeFilter
  id: IntFilter
  student: StudentRelationFilter
  studentId: IntNullableFilter
  submissionFiles: SubmissionFileListRelationFilter
  updatedAt: DateTimeFilter
}

input SubmissionWhereUniqueInput {
  id: Int
}

type Teacher {
  _count: TeacherCount
  courses(cursor: CourseWhereUniqueInput, distinct: [CourseScalarFieldEnum!], orderBy: [CourseOrderByWithRelationInput!], skip: Int, take: Int, where: CourseWhereInput): [Course!]!
  firstName: String!
  id: Int!
  lastName: String!
  user: User!
  userId: Int!
}

type TeacherAvgAggregate {
  id: Float
  userId: Float
}

input TeacherAvgOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

type TeacherCount {
  courses: Int!
}

type TeacherCountAggregate {
  _all: Int!
  firstName: Int!
  id: Int!
  lastName: Int!
  userId: Int!
}

input TeacherCountOrderByAggregateInput {
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  userId: SortOrder
}

input TeacherCreateInput {
  courses: CourseCreateNestedManyWithoutTeacherInput
  firstName: String!
  lastName: String!
  user: UserCreateNestedOneWithoutTeacherInput!
}

input TeacherCreateNestedOneWithoutCoursesInput {
  connect: TeacherWhereUniqueInput
  connectOrCreate: TeacherCreateOrConnectWithoutCoursesInput
  create: TeacherCreateWithoutCoursesInput
}

input TeacherCreateNestedOneWithoutUserInput {
  connect: TeacherWhereUniqueInput
  connectOrCreate: TeacherCreateOrConnectWithoutUserInput
  create: TeacherCreateWithoutUserInput
}

input TeacherCreateOrConnectWithoutCoursesInput {
  create: TeacherCreateWithoutCoursesInput!
  where: TeacherWhereUniqueInput!
}

input TeacherCreateOrConnectWithoutUserInput {
  create: TeacherCreateWithoutUserInput!
  where: TeacherWhereUniqueInput!
}

input TeacherCreateWithoutCoursesInput {
  firstName: String!
  lastName: String!
  user: UserCreateNestedOneWithoutTeacherInput!
}

input TeacherCreateWithoutUserInput {
  courses: CourseCreateNestedManyWithoutTeacherInput
  firstName: String!
  lastName: String!
}

type TeacherGroupBy {
  _avg: TeacherAvgAggregate
  _count: TeacherCountAggregate
  _max: TeacherMaxAggregate
  _min: TeacherMinAggregate
  _sum: TeacherSumAggregate
  firstName: String!
  id: Int!
  lastName: String!
  userId: Int!
}

type TeacherMaxAggregate {
  firstName: String
  id: Int
  lastName: String
  userId: Int
}

input TeacherMaxOrderByAggregateInput {
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  userId: SortOrder
}

type TeacherMinAggregate {
  firstName: String
  id: Int
  lastName: String
  userId: Int
}

input TeacherMinOrderByAggregateInput {
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  userId: SortOrder
}

input TeacherOrderByWithAggregationInput {
  _avg: TeacherAvgOrderByAggregateInput
  _count: TeacherCountOrderByAggregateInput
  _max: TeacherMaxOrderByAggregateInput
  _min: TeacherMinOrderByAggregateInput
  _sum: TeacherSumOrderByAggregateInput
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  userId: SortOrder
}

input TeacherOrderByWithRelationInput {
  courses: CourseOrderByRelationAggregateInput
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input TeacherRelationFilter {
  is: TeacherWhereInput
  isNot: TeacherWhereInput
}

enum TeacherScalarFieldEnum {
  firstName
  id
  lastName
  userId
}

input TeacherScalarWhereWithAggregatesInput {
  AND: [TeacherScalarWhereWithAggregatesInput!]
  NOT: [TeacherScalarWhereWithAggregatesInput!]
  OR: [TeacherScalarWhereWithAggregatesInput!]
  firstName: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type TeacherSumAggregate {
  id: Int
  userId: Int
}

input TeacherSumOrderByAggregateInput {
  id: SortOrder
  userId: SortOrder
}

input TeacherUpdateInput {
  courses: CourseUpdateManyWithoutTeacherInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutTeacherInput
}

input TeacherUpdateManyMutationInput {
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
}

input TeacherUpdateOneWithoutCoursesInput {
  connect: TeacherWhereUniqueInput
  connectOrCreate: TeacherCreateOrConnectWithoutCoursesInput
  create: TeacherCreateWithoutCoursesInput
  delete: Boolean
  disconnect: Boolean
  update: TeacherUpdateWithoutCoursesInput
  upsert: TeacherUpsertWithoutCoursesInput
}

input TeacherUpdateOneWithoutUserInput {
  connect: TeacherWhereUniqueInput
  connectOrCreate: TeacherCreateOrConnectWithoutUserInput
  create: TeacherCreateWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  update: TeacherUpdateWithoutUserInput
  upsert: TeacherUpsertWithoutUserInput
}

input TeacherUpdateWithoutCoursesInput {
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutTeacherInput
}

input TeacherUpdateWithoutUserInput {
  courses: CourseUpdateManyWithoutTeacherInput
  firstName: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
}

input TeacherUpsertWithoutCoursesInput {
  create: TeacherCreateWithoutCoursesInput!
  update: TeacherUpdateWithoutCoursesInput!
}

input TeacherUpsertWithoutUserInput {
  create: TeacherCreateWithoutUserInput!
  update: TeacherUpdateWithoutUserInput!
}

input TeacherWhereInput {
  AND: [TeacherWhereInput!]
  NOT: [TeacherWhereInput!]
  OR: [TeacherWhereInput!]
  courses: CourseListRelationFilter
  firstName: StringFilter
  id: IntFilter
  lastName: StringFilter
  user: UserRelationFilter
  userId: IntFilter
}

input TeacherWhereUniqueInput {
  id: Int
  userId: Int
}

type Topic {
  _count: TopicCount
  courses(cursor: CourseWhereUniqueInput, distinct: [CourseScalarFieldEnum!], orderBy: [CourseOrderByWithRelationInput!], skip: Int, take: Int, where: CourseWhereInput): [Course!]!
  department: Department
  departmentId: Int
  grades: Int!
  id: Int!
  name: String!
  students(cursor: StudentWhereUniqueInput, distinct: [StudentScalarFieldEnum!], orderBy: [StudentOrderByWithRelationInput!], skip: Int, take: Int, where: StudentWhereInput): [Student!]!
}

type TopicAvgAggregate {
  departmentId: Float
  grades: Float
  id: Float
}

input TopicAvgOrderByAggregateInput {
  departmentId: SortOrder
  grades: SortOrder
  id: SortOrder
}

type TopicCount {
  courses: Int!
  students: Int!
}

type TopicCountAggregate {
  _all: Int!
  departmentId: Int!
  grades: Int!
  id: Int!
  name: Int!
}

input TopicCountOrderByAggregateInput {
  departmentId: SortOrder
  grades: SortOrder
  id: SortOrder
  name: SortOrder
}

input TopicCreateInput {
  courses: CourseCreateNestedManyWithoutTopicInput
  department: DepartmentCreateNestedOneWithoutTopicsInput
  grades: Int!
  name: String!
  students: StudentCreateNestedManyWithoutTopicInput
}

input TopicCreateNestedManyWithoutDepartmentInput {
  connect: [TopicWhereUniqueInput!]
  connectOrCreate: [TopicCreateOrConnectWithoutDepartmentInput!]
  create: [TopicCreateWithoutDepartmentInput!]
}

input TopicCreateNestedOneWithoutCoursesInput {
  connect: TopicWhereUniqueInput
  connectOrCreate: TopicCreateOrConnectWithoutCoursesInput
  create: TopicCreateWithoutCoursesInput
}

input TopicCreateNestedOneWithoutStudentsInput {
  connect: TopicWhereUniqueInput
  connectOrCreate: TopicCreateOrConnectWithoutStudentsInput
  create: TopicCreateWithoutStudentsInput
}

input TopicCreateOrConnectWithoutCoursesInput {
  create: TopicCreateWithoutCoursesInput!
  where: TopicWhereUniqueInput!
}

input TopicCreateOrConnectWithoutDepartmentInput {
  create: TopicCreateWithoutDepartmentInput!
  where: TopicWhereUniqueInput!
}

input TopicCreateOrConnectWithoutStudentsInput {
  create: TopicCreateWithoutStudentsInput!
  where: TopicWhereUniqueInput!
}

input TopicCreateWithoutCoursesInput {
  department: DepartmentCreateNestedOneWithoutTopicsInput
  grades: Int!
  name: String!
  students: StudentCreateNestedManyWithoutTopicInput
}

input TopicCreateWithoutDepartmentInput {
  courses: CourseCreateNestedManyWithoutTopicInput
  grades: Int!
  name: String!
  students: StudentCreateNestedManyWithoutTopicInput
}

input TopicCreateWithoutStudentsInput {
  courses: CourseCreateNestedManyWithoutTopicInput
  department: DepartmentCreateNestedOneWithoutTopicsInput
  grades: Int!
  name: String!
}

type TopicGroupBy {
  _avg: TopicAvgAggregate
  _count: TopicCountAggregate
  _max: TopicMaxAggregate
  _min: TopicMinAggregate
  _sum: TopicSumAggregate
  departmentId: Int
  grades: Int!
  id: Int!
  name: String!
}

input TopicListRelationFilter {
  every: TopicWhereInput
  none: TopicWhereInput
  some: TopicWhereInput
}

type TopicMaxAggregate {
  departmentId: Int
  grades: Int
  id: Int
  name: String
}

input TopicMaxOrderByAggregateInput {
  departmentId: SortOrder
  grades: SortOrder
  id: SortOrder
  name: SortOrder
}

type TopicMinAggregate {
  departmentId: Int
  grades: Int
  id: Int
  name: String
}

input TopicMinOrderByAggregateInput {
  departmentId: SortOrder
  grades: SortOrder
  id: SortOrder
  name: SortOrder
}

input TopicOrderByRelationAggregateInput {
  _count: SortOrder
}

input TopicOrderByWithAggregationInput {
  _avg: TopicAvgOrderByAggregateInput
  _count: TopicCountOrderByAggregateInput
  _max: TopicMaxOrderByAggregateInput
  _min: TopicMinOrderByAggregateInput
  _sum: TopicSumOrderByAggregateInput
  departmentId: SortOrder
  grades: SortOrder
  id: SortOrder
  name: SortOrder
}

input TopicOrderByWithRelationInput {
  courses: CourseOrderByRelationAggregateInput
  department: DepartmentOrderByWithRelationInput
  departmentId: SortOrder
  grades: SortOrder
  id: SortOrder
  name: SortOrder
  students: StudentOrderByRelationAggregateInput
}

input TopicRelationFilter {
  is: TopicWhereInput
  isNot: TopicWhereInput
}

enum TopicScalarFieldEnum {
  departmentId
  grades
  id
  name
}

input TopicScalarWhereInput {
  AND: [TopicScalarWhereInput!]
  NOT: [TopicScalarWhereInput!]
  OR: [TopicScalarWhereInput!]
  departmentId: IntNullableFilter
  grades: IntFilter
  id: IntFilter
  name: StringFilter
}

input TopicScalarWhereWithAggregatesInput {
  AND: [TopicScalarWhereWithAggregatesInput!]
  NOT: [TopicScalarWhereWithAggregatesInput!]
  OR: [TopicScalarWhereWithAggregatesInput!]
  departmentId: IntNullableWithAggregatesFilter
  grades: IntWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type TopicSumAggregate {
  departmentId: Int
  grades: Int
  id: Int
}

input TopicSumOrderByAggregateInput {
  departmentId: SortOrder
  grades: SortOrder
  id: SortOrder
}

input TopicUpdateInput {
  courses: CourseUpdateManyWithoutTopicInput
  department: DepartmentUpdateOneWithoutTopicsInput
  grades: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  students: StudentUpdateManyWithoutTopicInput
}

input TopicUpdateManyMutationInput {
  grades: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input TopicUpdateManyWithWhereWithoutDepartmentInput {
  data: TopicUpdateManyMutationInput!
  where: TopicScalarWhereInput!
}

input TopicUpdateManyWithoutDepartmentInput {
  connect: [TopicWhereUniqueInput!]
  connectOrCreate: [TopicCreateOrConnectWithoutDepartmentInput!]
  create: [TopicCreateWithoutDepartmentInput!]
  delete: [TopicWhereUniqueInput!]
  deleteMany: [TopicScalarWhereInput!]
  disconnect: [TopicWhereUniqueInput!]
  set: [TopicWhereUniqueInput!]
  update: [TopicUpdateWithWhereUniqueWithoutDepartmentInput!]
  updateMany: [TopicUpdateManyWithWhereWithoutDepartmentInput!]
  upsert: [TopicUpsertWithWhereUniqueWithoutDepartmentInput!]
}

input TopicUpdateOneWithoutCoursesInput {
  connect: TopicWhereUniqueInput
  connectOrCreate: TopicCreateOrConnectWithoutCoursesInput
  create: TopicCreateWithoutCoursesInput
  delete: Boolean
  disconnect: Boolean
  update: TopicUpdateWithoutCoursesInput
  upsert: TopicUpsertWithoutCoursesInput
}

input TopicUpdateOneWithoutStudentsInput {
  connect: TopicWhereUniqueInput
  connectOrCreate: TopicCreateOrConnectWithoutStudentsInput
  create: TopicCreateWithoutStudentsInput
  delete: Boolean
  disconnect: Boolean
  update: TopicUpdateWithoutStudentsInput
  upsert: TopicUpsertWithoutStudentsInput
}

input TopicUpdateWithWhereUniqueWithoutDepartmentInput {
  data: TopicUpdateWithoutDepartmentInput!
  where: TopicWhereUniqueInput!
}

input TopicUpdateWithoutCoursesInput {
  department: DepartmentUpdateOneWithoutTopicsInput
  grades: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  students: StudentUpdateManyWithoutTopicInput
}

input TopicUpdateWithoutDepartmentInput {
  courses: CourseUpdateManyWithoutTopicInput
  grades: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  students: StudentUpdateManyWithoutTopicInput
}

input TopicUpdateWithoutStudentsInput {
  courses: CourseUpdateManyWithoutTopicInput
  department: DepartmentUpdateOneWithoutTopicsInput
  grades: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input TopicUpsertWithWhereUniqueWithoutDepartmentInput {
  create: TopicCreateWithoutDepartmentInput!
  update: TopicUpdateWithoutDepartmentInput!
  where: TopicWhereUniqueInput!
}

input TopicUpsertWithoutCoursesInput {
  create: TopicCreateWithoutCoursesInput!
  update: TopicUpdateWithoutCoursesInput!
}

input TopicUpsertWithoutStudentsInput {
  create: TopicCreateWithoutStudentsInput!
  update: TopicUpdateWithoutStudentsInput!
}

input TopicWhereInput {
  AND: [TopicWhereInput!]
  NOT: [TopicWhereInput!]
  OR: [TopicWhereInput!]
  courses: CourseListRelationFilter
  department: DepartmentRelationFilter
  departmentId: IntNullableFilter
  grades: IntFilter
  id: IntFilter
  name: StringFilter
  students: StudentListRelationFilter
}

input TopicWhereUniqueInput {
  id: Int
}

type User {
  admin: Admin
  createdAt: DateTime!
  disabled: Boolean!
  email: String!
  id: Int!
  role: String!
  student: Student
  teacher: Teacher
  updatedAt: DateTime!
  username: String!
}

type UserAvgAggregate {
  id: Float
}

input UserAvgOrderByAggregateInput {
  id: SortOrder
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int!
  disabled: Int!
  email: Int!
  id: Int!
  password: Int!
  role: Int!
  updatedAt: Int!
  username: Int!
}

input UserCountOrderByAggregateInput {
  createdAt: SortOrder
  disabled: SortOrder
  email: SortOrder
  id: SortOrder
  password: SortOrder
  role: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

input UserCreateInput {
  admin: AdminCreateNestedOneWithoutUserInput
  createdAt: DateTime
  disabled: Boolean!
  email: String!
  password: String!
  role: String!
  student: StudentCreateNestedOneWithoutUserInput
  teacher: TeacherCreateNestedOneWithoutUserInput
  updatedAt: DateTime
  username: String!
}

input UserCreateNestedOneWithoutAdminInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAdminInput
  create: UserCreateWithoutAdminInput
}

input UserCreateNestedOneWithoutStudentInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutStudentInput
  create: UserCreateWithoutStudentInput
}

input UserCreateNestedOneWithoutTeacherInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutTeacherInput
  create: UserCreateWithoutTeacherInput
}

input UserCreateOrConnectWithoutAdminInput {
  create: UserCreateWithoutAdminInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutStudentInput {
  create: UserCreateWithoutStudentInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutTeacherInput {
  create: UserCreateWithoutTeacherInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutAdminInput {
  createdAt: DateTime
  disabled: Boolean!
  email: String!
  password: String!
  role: String!
  student: StudentCreateNestedOneWithoutUserInput
  teacher: TeacherCreateNestedOneWithoutUserInput
  updatedAt: DateTime
  username: String!
}

input UserCreateWithoutStudentInput {
  admin: AdminCreateNestedOneWithoutUserInput
  createdAt: DateTime
  disabled: Boolean!
  email: String!
  password: String!
  role: String!
  teacher: TeacherCreateNestedOneWithoutUserInput
  updatedAt: DateTime
  username: String!
}

input UserCreateWithoutTeacherInput {
  admin: AdminCreateNestedOneWithoutUserInput
  createdAt: DateTime
  disabled: Boolean!
  email: String!
  password: String!
  role: String!
  student: StudentCreateNestedOneWithoutUserInput
  updatedAt: DateTime
  username: String!
}

type UserGroupBy {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
  createdAt: DateTime!
  disabled: Boolean!
  email: String!
  id: Int!
  password: String!
  role: String!
  updatedAt: DateTime!
  username: String!
}

type UserMaxAggregate {
  createdAt: DateTime
  disabled: Boolean
  email: String
  id: Int
  password: String
  role: String
  updatedAt: DateTime
  username: String
}

input UserMaxOrderByAggregateInput {
  createdAt: SortOrder
  disabled: SortOrder
  email: SortOrder
  id: SortOrder
  password: SortOrder
  role: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

type UserMinAggregate {
  createdAt: DateTime
  disabled: Boolean
  email: String
  id: Int
  password: String
  role: String
  updatedAt: DateTime
  username: String
}

input UserMinOrderByAggregateInput {
  createdAt: SortOrder
  disabled: SortOrder
  email: SortOrder
  id: SortOrder
  password: SortOrder
  role: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

input UserOrderByWithAggregationInput {
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
  createdAt: SortOrder
  disabled: SortOrder
  email: SortOrder
  id: SortOrder
  password: SortOrder
  role: SortOrder
  updatedAt: SortOrder
  username: SortOrder
}

input UserOrderByWithRelationInput {
  admin: AdminOrderByWithRelationInput
  createdAt: SortOrder
  disabled: SortOrder
  email: SortOrder
  id: SortOrder
  password: SortOrder
  role: SortOrder
  student: StudentOrderByWithRelationInput
  teacher: TeacherOrderByWithRelationInput
  updatedAt: SortOrder
  username: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  disabled
  email
  id
  password
  role
  updatedAt
  username
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  disabled: BoolWithAggregatesFilter
  email: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  password: StringWithAggregatesFilter
  role: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  username: StringWithAggregatesFilter
}

type UserSumAggregate {
  id: Int
}

input UserSumOrderByAggregateInput {
  id: SortOrder
}

input UserUpdateInput {
  admin: AdminUpdateOneWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  disabled: BoolFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: StringFieldUpdateOperationsInput
  student: StudentUpdateOneWithoutUserInput
  teacher: TeacherUpdateOneWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  disabled: BoolFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutAdminInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutAdminInput
  create: UserCreateWithoutAdminInput
  update: UserUpdateWithoutAdminInput
  upsert: UserUpsertWithoutAdminInput
}

input UserUpdateOneRequiredWithoutStudentInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutStudentInput
  create: UserCreateWithoutStudentInput
  update: UserUpdateWithoutStudentInput
  upsert: UserUpsertWithoutStudentInput
}

input UserUpdateOneRequiredWithoutTeacherInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutTeacherInput
  create: UserCreateWithoutTeacherInput
  update: UserUpdateWithoutTeacherInput
  upsert: UserUpsertWithoutTeacherInput
}

input UserUpdateWithoutAdminInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  disabled: BoolFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: StringFieldUpdateOperationsInput
  student: StudentUpdateOneWithoutUserInput
  teacher: TeacherUpdateOneWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateWithoutStudentInput {
  admin: AdminUpdateOneWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  disabled: BoolFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: StringFieldUpdateOperationsInput
  teacher: TeacherUpdateOneWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UserUpdateWithoutTeacherInput {
  admin: AdminUpdateOneWithoutUserInput
  createdAt: DateTimeFieldUpdateOperationsInput
  disabled: BoolFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  role: StringFieldUpdateOperationsInput
  student: StudentUpdateOneWithoutUserInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input UserUpsertWithoutAdminInput {
  create: UserCreateWithoutAdminInput!
  update: UserUpdateWithoutAdminInput!
}

input UserUpsertWithoutStudentInput {
  create: UserCreateWithoutStudentInput!
  update: UserUpdateWithoutStudentInput!
}

input UserUpsertWithoutTeacherInput {
  create: UserCreateWithoutTeacherInput!
  update: UserUpdateWithoutTeacherInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  admin: AdminRelationFilter
  createdAt: DateTimeFilter
  disabled: BoolFilter
  email: StringFilter
  id: IntFilter
  password: StringFilter
  role: StringFilter
  student: StudentRelationFilter
  teacher: TeacherRelationFilter
  updatedAt: DateTimeFilter
  username: StringFilter
}

input UserWhereUniqueInput {
  id: Int
}
